/* tslint:disable */
/* eslint-disable */
/**
 * Data API
 * Serves the Clever Data API
 *
 * The version of the OpenAPI document: 2.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AdminName
 */
export interface AdminName {
    /**
     * 
     * @type {string}
     * @memberof AdminName
     */
    'first'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AdminName
     */
    'last'?: string | null;
}
/**
 * 
 * @export
 * @interface BadRequest
 */
export interface BadRequest {
    /**
     * 
     * @type {string}
     * @memberof BadRequest
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Contact
 */
export interface Contact {
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'district'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'phone_type'?: ContactPhoneTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'relationship'?: ContactRelationshipEnum;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'sis_id'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Contact
     */
    'students'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'type'?: ContactTypeEnum;
}

export const ContactPhoneTypeEnum = {
    Cell: 'Cell',
    Home: 'Home',
    Work: 'Work',
    Other: 'Other',
    Empty: ''
} as const;

export type ContactPhoneTypeEnum = typeof ContactPhoneTypeEnum[keyof typeof ContactPhoneTypeEnum];
export const ContactRelationshipEnum = {
    Parent: 'Parent',
    Grandparent: 'Grandparent',
    Self: 'Self',
    AuntUncle: 'Aunt/Uncle',
    Sibling: 'Sibling',
    Other: 'Other',
    Empty: ''
} as const;

export type ContactRelationshipEnum = typeof ContactRelationshipEnum[keyof typeof ContactRelationshipEnum];
export const ContactTypeEnum = {
    ParentGuardian: 'Parent/Guardian',
    Emergency: 'Emergency',
    Primary: 'Primary',
    Secondary: 'Secondary',
    Family: 'Family',
    Other: 'Other',
    Empty: ''
} as const;

export type ContactTypeEnum = typeof ContactTypeEnum[keyof typeof ContactTypeEnum];

/**
 * 
 * @export
 * @interface ContactObject
 */
export interface ContactObject {
    /**
     * 
     * @type {Contact}
     * @memberof ContactObject
     */
    'object'?: Contact;
}
/**
 * 
 * @export
 * @interface ContactResponse
 */
export interface ContactResponse {
    /**
     * 
     * @type {Contact}
     * @memberof ContactResponse
     */
    'data'?: Contact;
}
/**
 * 
 * @export
 * @interface ContactsCreated
 */
export interface ContactsCreated extends Event {
    /**
     * 
     * @type {ContactObject}
     * @memberof ContactsCreated
     */
    'data'?: ContactObject;
}
/**
 * 
 * @export
 * @interface ContactsCreatedAllOf
 */
export interface ContactsCreatedAllOf {
    /**
     * 
     * @type {ContactObject}
     * @memberof ContactsCreatedAllOf
     */
    'data'?: ContactObject;
}
/**
 * 
 * @export
 * @interface ContactsDeleted
 */
export interface ContactsDeleted extends Event {
    /**
     * 
     * @type {ContactObject}
     * @memberof ContactsDeleted
     */
    'data'?: ContactObject;
}
/**
 * 
 * @export
 * @interface ContactsResponse
 */
export interface ContactsResponse {
    /**
     * 
     * @type {Array<ContactResponse>}
     * @memberof ContactsResponse
     */
    'data'?: Array<ContactResponse>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof ContactsResponse
     */
    'links'?: Array<Link>;
}
/**
 * 
 * @export
 * @interface ContactsUpdated
 */
export interface ContactsUpdated extends Event {
    /**
     * 
     * @type {ContactObject}
     * @memberof ContactsUpdated
     */
    'data'?: ContactObject;
    /**
     * 
     * @type {object}
     * @memberof ContactsUpdated
     */
    'previous_attributes'?: object;
}
/**
 * 
 * @export
 * @interface ContactsUpdatedAllOf
 */
export interface ContactsUpdatedAllOf {
    /**
     * 
     * @type {ContactObject}
     * @memberof ContactsUpdatedAllOf
     */
    'data'?: ContactObject;
    /**
     * 
     * @type {object}
     * @memberof ContactsUpdatedAllOf
     */
    'previous_attributes'?: object;
}
/**
 * 
 * @export
 * @interface Course
 */
export interface Course {
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'district'?: string;
}
/**
 * 
 * @export
 * @interface CourseObject
 */
export interface CourseObject {
    /**
     * 
     * @type {Course}
     * @memberof CourseObject
     */
    'object'?: Course;
}
/**
 * 
 * @export
 * @interface CourseResponse
 */
export interface CourseResponse {
    /**
     * 
     * @type {Course}
     * @memberof CourseResponse
     */
    'data'?: Course;
}
/**
 * 
 * @export
 * @interface CoursesCreated
 */
export interface CoursesCreated extends Event {
    /**
     * 
     * @type {CourseObject}
     * @memberof CoursesCreated
     */
    'data'?: CourseObject;
}
/**
 * 
 * @export
 * @interface CoursesCreatedAllOf
 */
export interface CoursesCreatedAllOf {
    /**
     * 
     * @type {CourseObject}
     * @memberof CoursesCreatedAllOf
     */
    'data'?: CourseObject;
}
/**
 * 
 * @export
 * @interface CoursesDeleted
 */
export interface CoursesDeleted extends Event {
    /**
     * 
     * @type {CourseObject}
     * @memberof CoursesDeleted
     */
    'data'?: CourseObject;
}
/**
 * 
 * @export
 * @interface CoursesResponse
 */
export interface CoursesResponse {
    /**
     * 
     * @type {Array<CourseResponse>}
     * @memberof CoursesResponse
     */
    'data'?: Array<CourseResponse>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof CoursesResponse
     */
    'links'?: Array<Link>;
}
/**
 * 
 * @export
 * @interface CoursesUpdated
 */
export interface CoursesUpdated extends Event {
    /**
     * 
     * @type {CourseObject}
     * @memberof CoursesUpdated
     */
    'data'?: CourseObject;
    /**
     * 
     * @type {object}
     * @memberof CoursesUpdated
     */
    'previous_attributes'?: object;
}
/**
 * 
 * @export
 * @interface CoursesUpdatedAllOf
 */
export interface CoursesUpdatedAllOf {
    /**
     * 
     * @type {CourseObject}
     * @memberof CoursesUpdatedAllOf
     */
    'data'?: CourseObject;
    /**
     * 
     * @type {object}
     * @memberof CoursesUpdatedAllOf
     */
    'previous_attributes'?: object;
}
/**
 * 
 * @export
 * @interface Credentials
 */
export interface Credentials {
    /**
     * 
     * @type {string}
     * @memberof Credentials
     */
    'district_username'?: string;
}
/**
 * 
 * @export
 * @interface District
 */
export interface District {
    /**
     * 
     * @type {string}
     * @memberof District
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof District
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof District
     */
    'mdr_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof District
     */
    'nces_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof District
     */
    'sis_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof District
     */
    'state'?: DistrictStateEnum;
    /**
     * 
     * @type {string}
     * @memberof District
     */
    'last_sync'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof District
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof District
     */
    'pause_start'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof District
     */
    'pause_end'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof District
     */
    'launch_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof District
     */
    'portal_url'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof District
     */
    'login_methods'?: Array<string>;
    /**
     * 
     * @type {DistrictAdmin}
     * @memberof District
     */
    'district_contact'?: DistrictAdmin;
}

export const DistrictStateEnum = {
    Running: 'running',
    Pending: 'pending',
    Error: 'error',
    Paused: 'paused',
    Empty: '',
    Success: 'success'
} as const;

export type DistrictStateEnum = typeof DistrictStateEnum[keyof typeof DistrictStateEnum];

/**
 * 
 * @export
 * @interface DistrictAdmin
 */
export interface DistrictAdmin {
    /**
     * 
     * @type {string}
     * @memberof DistrictAdmin
     */
    'id'?: string;
    /**
     * 
     * @type {AdminName}
     * @memberof DistrictAdmin
     */
    'name'?: AdminName;
    /**
     * 
     * @type {string}
     * @memberof DistrictAdmin
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof DistrictAdmin
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DistrictAdmin
     */
    'district'?: string;
}
/**
 * 
 * @export
 * @interface DistrictAdminObject
 */
export interface DistrictAdminObject {
    /**
     * 
     * @type {DistrictAdmin}
     * @memberof DistrictAdminObject
     */
    'object'?: DistrictAdmin;
}
/**
 * 
 * @export
 * @interface DistrictAdminResponse
 */
export interface DistrictAdminResponse {
    /**
     * 
     * @type {DistrictAdmin}
     * @memberof DistrictAdminResponse
     */
    'data'?: DistrictAdmin;
}
/**
 * 
 * @export
 * @interface DistrictAdminsResponse
 */
export interface DistrictAdminsResponse {
    /**
     * 
     * @type {Array<DistrictAdminResponse>}
     * @memberof DistrictAdminsResponse
     */
    'data'?: Array<DistrictAdminResponse>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof DistrictAdminsResponse
     */
    'links'?: Array<Link>;
}
/**
 * 
 * @export
 * @interface DistrictObject
 */
export interface DistrictObject {
    /**
     * 
     * @type {District}
     * @memberof DistrictObject
     */
    'object'?: District;
}
/**
 * 
 * @export
 * @interface DistrictResponse
 */
export interface DistrictResponse {
    /**
     * 
     * @type {District}
     * @memberof DistrictResponse
     */
    'data'?: District;
}
/**
 * 
 * @export
 * @interface DistrictadminsCreated
 */
export interface DistrictadminsCreated extends Event {
    /**
     * 
     * @type {DistrictAdminObject}
     * @memberof DistrictadminsCreated
     */
    'data'?: DistrictAdminObject;
}
/**
 * 
 * @export
 * @interface DistrictadminsCreatedAllOf
 */
export interface DistrictadminsCreatedAllOf {
    /**
     * 
     * @type {DistrictAdminObject}
     * @memberof DistrictadminsCreatedAllOf
     */
    'data'?: DistrictAdminObject;
}
/**
 * 
 * @export
 * @interface DistrictadminsDeleted
 */
export interface DistrictadminsDeleted extends Event {
    /**
     * 
     * @type {DistrictAdminObject}
     * @memberof DistrictadminsDeleted
     */
    'data'?: DistrictAdminObject;
}
/**
 * 
 * @export
 * @interface DistrictadminsUpdated
 */
export interface DistrictadminsUpdated extends Event {
    /**
     * 
     * @type {DistrictAdminObject}
     * @memberof DistrictadminsUpdated
     */
    'data'?: DistrictAdminObject;
    /**
     * 
     * @type {object}
     * @memberof DistrictadminsUpdated
     */
    'previous_attributes'?: object;
}
/**
 * 
 * @export
 * @interface DistrictadminsUpdatedAllOf
 */
export interface DistrictadminsUpdatedAllOf {
    /**
     * 
     * @type {DistrictAdminObject}
     * @memberof DistrictadminsUpdatedAllOf
     */
    'data'?: DistrictAdminObject;
    /**
     * 
     * @type {object}
     * @memberof DistrictadminsUpdatedAllOf
     */
    'previous_attributes'?: object;
}
/**
 * 
 * @export
 * @interface DistrictsCreated
 */
export interface DistrictsCreated extends Event {
    /**
     * 
     * @type {DistrictObject}
     * @memberof DistrictsCreated
     */
    'data'?: DistrictObject;
}
/**
 * 
 * @export
 * @interface DistrictsCreatedAllOf
 */
export interface DistrictsCreatedAllOf {
    /**
     * 
     * @type {DistrictObject}
     * @memberof DistrictsCreatedAllOf
     */
    'data'?: DistrictObject;
}
/**
 * 
 * @export
 * @interface DistrictsDeleted
 */
export interface DistrictsDeleted extends Event {
    /**
     * 
     * @type {DistrictObject}
     * @memberof DistrictsDeleted
     */
    'data'?: DistrictObject;
}
/**
 * 
 * @export
 * @interface DistrictsResponse
 */
export interface DistrictsResponse {
    /**
     * 
     * @type {Array<DistrictResponse>}
     * @memberof DistrictsResponse
     */
    'data'?: Array<DistrictResponse>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof DistrictsResponse
     */
    'links'?: Array<Link>;
}
/**
 * 
 * @export
 * @interface DistrictsUpdated
 */
export interface DistrictsUpdated extends Event {
    /**
     * 
     * @type {DistrictObject}
     * @memberof DistrictsUpdated
     */
    'data'?: DistrictObject;
    /**
     * 
     * @type {object}
     * @memberof DistrictsUpdated
     */
    'previous_attributes'?: object;
}
/**
 * 
 * @export
 * @interface DistrictsUpdatedAllOf
 */
export interface DistrictsUpdatedAllOf {
    /**
     * 
     * @type {DistrictObject}
     * @memberof DistrictsUpdatedAllOf
     */
    'data'?: DistrictObject;
    /**
     * 
     * @type {object}
     * @memberof DistrictsUpdatedAllOf
     */
    'previous_attributes'?: object;
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface EventResponse
 */
export interface EventResponse {
    /**
     * 
     * @type {Event}
     * @memberof EventResponse
     */
    'data'?: Event;
}
/**
 * 
 * @export
 * @interface EventsResponse
 */
export interface EventsResponse {
    /**
     * 
     * @type {Array<EventResponse>}
     * @memberof EventsResponse
     */
    'data'?: Array<EventResponse>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof EventsResponse
     */
    'links'?: Array<Link>;
}
/**
 * 
 * @export
 * @interface InternalError
 */
export interface InternalError {
    /**
     * 
     * @type {string}
     * @memberof InternalError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'rel'?: LinkRelEnum;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'uri'?: string;
}

export const LinkRelEnum = {
    Next: 'next',
    Prev: 'prev',
    Self: 'self'
} as const;

export type LinkRelEnum = typeof LinkRelEnum[keyof typeof LinkRelEnum];

/**
 * 
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'address'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'city'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'state'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'zip'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'lat'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'lon'?: string | null;
}
/**
 * 
 * @export
 * @interface Name
 */
export interface Name {
    /**
     * 
     * @type {string}
     * @memberof Name
     */
    'first'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Name
     */
    'middle'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Name
     */
    'last'?: string | null;
}
/**
 * 
 * @export
 * @interface NotFound
 */
export interface NotFound {
    /**
     * 
     * @type {string}
     * @memberof NotFound
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Principal
 */
export interface Principal {
    /**
     * 
     * @type {string}
     * @memberof Principal
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Principal
     */
    'email'?: string | null;
}
/**
 * 
 * @export
 * @interface School
 */
export interface School {
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'district'?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'high_grade'?: SchoolHighGradeEnum;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'last_modified'?: string;
    /**
     * 
     * @type {Location}
     * @memberof School
     */
    'location'?: Location;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'low_grade'?: SchoolLowGradeEnum;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'nces_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'phone'?: string | null;
    /**
     * 
     * @type {Principal}
     * @memberof School
     */
    'principal'?: Principal;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'school_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'sis_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'state_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'mdr_number'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof School
     */
    'ext'?: object;
}

export const SchoolHighGradeEnum = {
    InfantToddler: 'InfantToddler',
    Preschool: 'Preschool',
    PreKindergarten: 'PreKindergarten',
    TransitionalKindergarten: 'TransitionalKindergarten',
    Kindergarten: 'Kindergarten',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _13: '13',
    PostGraduate: 'PostGraduate',
    Ungraded: 'Ungraded',
    Other: 'Other',
    Empty: ''
} as const;

export type SchoolHighGradeEnum = typeof SchoolHighGradeEnum[keyof typeof SchoolHighGradeEnum];
export const SchoolLowGradeEnum = {
    InfantToddler: 'InfantToddler',
    Preschool: 'Preschool',
    PreKindergarten: 'PreKindergarten',
    TransitionalKindergarten: 'TransitionalKindergarten',
    Kindergarten: 'Kindergarten',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _13: '13',
    PostGraduate: 'PostGraduate',
    Ungraded: 'Ungraded',
    Other: 'Other',
    Empty: ''
} as const;

export type SchoolLowGradeEnum = typeof SchoolLowGradeEnum[keyof typeof SchoolLowGradeEnum];

/**
 * 
 * @export
 * @interface SchoolAdmin
 */
export interface SchoolAdmin {
    /**
     * 
     * @type {string}
     * @memberof SchoolAdmin
     */
    'id'?: string;
    /**
     * 
     * @type {Credentials}
     * @memberof SchoolAdmin
     */
    'credentials'?: Credentials;
    /**
     * 
     * @type {string}
     * @memberof SchoolAdmin
     */
    'district'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolAdmin
     */
    'email'?: string;
    /**
     * 
     * @type {AdminName}
     * @memberof SchoolAdmin
     */
    'name'?: AdminName;
    /**
     * 
     * @type {Array<string>}
     * @memberof SchoolAdmin
     */
    'schools'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SchoolAdmin
     */
    'staff_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolAdmin
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SchoolAdmin
     */
    'department'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof SchoolAdmin
     */
    'ext'?: object;
}
/**
 * 
 * @export
 * @interface SchoolAdminObject
 */
export interface SchoolAdminObject {
    /**
     * 
     * @type {SchoolAdmin}
     * @memberof SchoolAdminObject
     */
    'object'?: SchoolAdmin;
}
/**
 * 
 * @export
 * @interface SchoolAdminResponse
 */
export interface SchoolAdminResponse {
    /**
     * 
     * @type {SchoolAdmin}
     * @memberof SchoolAdminResponse
     */
    'data'?: SchoolAdmin;
}
/**
 * 
 * @export
 * @interface SchoolAdminsResponse
 */
export interface SchoolAdminsResponse {
    /**
     * 
     * @type {Array<SchoolAdminResponse>}
     * @memberof SchoolAdminsResponse
     */
    'data'?: Array<SchoolAdminResponse>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof SchoolAdminsResponse
     */
    'links'?: Array<Link>;
}
/**
 * 
 * @export
 * @interface SchoolEnrollment
 */
export interface SchoolEnrollment {
    /**
     * 
     * @type {string}
     * @memberof SchoolEnrollment
     */
    'school'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolEnrollment
     */
    'start_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolEnrollment
     */
    'end_date'?: string;
}
/**
 * 
 * @export
 * @interface SchoolObject
 */
export interface SchoolObject {
    /**
     * 
     * @type {School}
     * @memberof SchoolObject
     */
    'object'?: School;
}
/**
 * 
 * @export
 * @interface SchoolResponse
 */
export interface SchoolResponse {
    /**
     * 
     * @type {School}
     * @memberof SchoolResponse
     */
    'data'?: School;
}
/**
 * 
 * @export
 * @interface SchooladminsCreated
 */
export interface SchooladminsCreated extends Event {
    /**
     * 
     * @type {SchoolAdminObject}
     * @memberof SchooladminsCreated
     */
    'data'?: SchoolAdminObject;
}
/**
 * 
 * @export
 * @interface SchooladminsCreatedAllOf
 */
export interface SchooladminsCreatedAllOf {
    /**
     * 
     * @type {SchoolAdminObject}
     * @memberof SchooladminsCreatedAllOf
     */
    'data'?: SchoolAdminObject;
}
/**
 * 
 * @export
 * @interface SchooladminsDeleted
 */
export interface SchooladminsDeleted extends Event {
    /**
     * 
     * @type {SchoolAdminObject}
     * @memberof SchooladminsDeleted
     */
    'data'?: SchoolAdminObject;
}
/**
 * 
 * @export
 * @interface SchooladminsUpdated
 */
export interface SchooladminsUpdated extends Event {
    /**
     * 
     * @type {SchoolAdminObject}
     * @memberof SchooladminsUpdated
     */
    'data'?: SchoolAdminObject;
    /**
     * 
     * @type {object}
     * @memberof SchooladminsUpdated
     */
    'previous_attributes'?: object;
}
/**
 * 
 * @export
 * @interface SchooladminsUpdatedAllOf
 */
export interface SchooladminsUpdatedAllOf {
    /**
     * 
     * @type {SchoolAdminObject}
     * @memberof SchooladminsUpdatedAllOf
     */
    'data'?: SchoolAdminObject;
    /**
     * 
     * @type {object}
     * @memberof SchooladminsUpdatedAllOf
     */
    'previous_attributes'?: object;
}
/**
 * 
 * @export
 * @interface SchoolsCreated
 */
export interface SchoolsCreated extends Event {
    /**
     * 
     * @type {SchoolObject}
     * @memberof SchoolsCreated
     */
    'data'?: SchoolObject;
}
/**
 * 
 * @export
 * @interface SchoolsCreatedAllOf
 */
export interface SchoolsCreatedAllOf {
    /**
     * 
     * @type {SchoolObject}
     * @memberof SchoolsCreatedAllOf
     */
    'data'?: SchoolObject;
}
/**
 * 
 * @export
 * @interface SchoolsDeleted
 */
export interface SchoolsDeleted extends Event {
    /**
     * 
     * @type {SchoolObject}
     * @memberof SchoolsDeleted
     */
    'data'?: SchoolObject;
}
/**
 * 
 * @export
 * @interface SchoolsResponse
 */
export interface SchoolsResponse {
    /**
     * 
     * @type {Array<SchoolResponse>}
     * @memberof SchoolsResponse
     */
    'data'?: Array<SchoolResponse>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof SchoolsResponse
     */
    'links'?: Array<Link>;
}
/**
 * 
 * @export
 * @interface SchoolsUpdated
 */
export interface SchoolsUpdated extends Event {
    /**
     * 
     * @type {SchoolObject}
     * @memberof SchoolsUpdated
     */
    'data'?: SchoolObject;
    /**
     * 
     * @type {object}
     * @memberof SchoolsUpdated
     */
    'previous_attributes'?: object;
}
/**
 * 
 * @export
 * @interface SchoolsUpdatedAllOf
 */
export interface SchoolsUpdatedAllOf {
    /**
     * 
     * @type {SchoolObject}
     * @memberof SchoolsUpdatedAllOf
     */
    'data'?: SchoolObject;
    /**
     * 
     * @type {object}
     * @memberof SchoolsUpdatedAllOf
     */
    'previous_attributes'?: object;
}
/**
 * 
 * @export
 * @interface Section
 */
export interface Section {
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'course'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'district'?: string;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'grade'?: SectionGradeEnum;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'last_modified'?: string;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'period'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'school'?: string;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'section_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'sis_id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Section
     */
    'students'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'subject'?: SectionSubjectEnum;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'teacher'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Section
     */
    'teachers'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'term_id'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof Section
     */
    'ext'?: object;
}

export const SectionGradeEnum = {
    InfantToddler: 'InfantToddler',
    Preschool: 'Preschool',
    PreKindergarten: 'PreKindergarten',
    TransitionalKindergarten: 'TransitionalKindergarten',
    Kindergarten: 'Kindergarten',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _13: '13',
    PostGraduate: 'PostGraduate',
    Ungraded: 'Ungraded',
    Other: 'Other',
    Empty: ''
} as const;

export type SectionGradeEnum = typeof SectionGradeEnum[keyof typeof SectionGradeEnum];
export const SectionSubjectEnum = {
    EnglishLanguageArts: 'english/language arts',
    Math: 'math',
    Science: 'science',
    SocialStudies: 'social studies',
    Language: 'language',
    HomeroomAdvisory: 'homeroom/advisory',
    InterventionsOnlineLearning: 'interventions/online learning',
    TechnologyAndEngineering: 'technology and engineering',
    PeAndHealth: 'PE and health',
    ArtsAndMusic: 'arts and music',
    Other: 'other',
    Empty: ''
} as const;

export type SectionSubjectEnum = typeof SectionSubjectEnum[keyof typeof SectionSubjectEnum];

/**
 * 
 * @export
 * @interface SectionObject
 */
export interface SectionObject {
    /**
     * 
     * @type {Section}
     * @memberof SectionObject
     */
    'object'?: Section;
}
/**
 * 
 * @export
 * @interface SectionResponse
 */
export interface SectionResponse {
    /**
     * 
     * @type {Section}
     * @memberof SectionResponse
     */
    'data'?: Section;
}
/**
 * 
 * @export
 * @interface SectionsCreated
 */
export interface SectionsCreated extends Event {
    /**
     * 
     * @type {SectionObject}
     * @memberof SectionsCreated
     */
    'data'?: SectionObject;
}
/**
 * 
 * @export
 * @interface SectionsCreatedAllOf
 */
export interface SectionsCreatedAllOf {
    /**
     * 
     * @type {SectionObject}
     * @memberof SectionsCreatedAllOf
     */
    'data'?: SectionObject;
}
/**
 * 
 * @export
 * @interface SectionsDeleted
 */
export interface SectionsDeleted extends Event {
    /**
     * 
     * @type {SectionObject}
     * @memberof SectionsDeleted
     */
    'data'?: SectionObject;
}
/**
 * 
 * @export
 * @interface SectionsResponse
 */
export interface SectionsResponse {
    /**
     * 
     * @type {Array<SectionResponse>}
     * @memberof SectionsResponse
     */
    'data'?: Array<SectionResponse>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof SectionsResponse
     */
    'links'?: Array<Link>;
}
/**
 * 
 * @export
 * @interface SectionsUpdated
 */
export interface SectionsUpdated extends Event {
    /**
     * 
     * @type {SectionObject}
     * @memberof SectionsUpdated
     */
    'data'?: SectionObject;
    /**
     * 
     * @type {object}
     * @memberof SectionsUpdated
     */
    'previous_attributes'?: object;
}
/**
 * 
 * @export
 * @interface SectionsUpdatedAllOf
 */
export interface SectionsUpdatedAllOf {
    /**
     * 
     * @type {SectionObject}
     * @memberof SectionsUpdatedAllOf
     */
    'data'?: SectionObject;
    /**
     * 
     * @type {object}
     * @memberof SectionsUpdatedAllOf
     */
    'previous_attributes'?: object;
}
/**
 * 
 * @export
 * @interface Student
 */
export interface Student {
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    'created'?: string;
    /**
     * 
     * @type {Credentials}
     * @memberof Student
     */
    'credentials'?: Credentials;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    'district'?: string;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    'dob'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    'ell_status'?: StudentEllStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    'email'?: string | null;
    /**
     * 
     * @type {Array<SchoolEnrollment>}
     * @memberof Student
     */
    'enrollments'?: Array<SchoolEnrollment>;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    'gender'?: StudentGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    'graduation_year'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    'grade'?: StudentGradeEnum;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    'hispanic_ethnicity'?: StudentHispanicEthnicityEnum;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    'home_language'?: StudentHomeLanguageEnum;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    'iep_status'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    'last_modified'?: string;
    /**
     * 
     * @type {Location}
     * @memberof Student
     */
    'location'?: Location;
    /**
     * 
     * @type {Name}
     * @memberof Student
     */
    'name'?: Name;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    'race'?: StudentRaceEnum;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    'school'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Student
     */
    'schools'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    'sis_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    'state_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    'student_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    'unweighted_gpa'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    'weighted_gpa'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof Student
     */
    'ext'?: object;
}

export const StudentEllStatusEnum = {
    Y: 'Y',
    N: 'N',
    Empty: ''
} as const;

export type StudentEllStatusEnum = typeof StudentEllStatusEnum[keyof typeof StudentEllStatusEnum];
export const StudentGenderEnum = {
    M: 'M',
    F: 'F',
    X: 'X',
    Empty: ''
} as const;

export type StudentGenderEnum = typeof StudentGenderEnum[keyof typeof StudentGenderEnum];
export const StudentGradeEnum = {
    InfantToddler: 'InfantToddler',
    Preschool: 'Preschool',
    PreKindergarten: 'PreKindergarten',
    TransitionalKindergarten: 'TransitionalKindergarten',
    Kindergarten: 'Kindergarten',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _13: '13',
    PostGraduate: 'PostGraduate',
    Ungraded: 'Ungraded',
    Other: 'Other',
    Empty: ''
} as const;

export type StudentGradeEnum = typeof StudentGradeEnum[keyof typeof StudentGradeEnum];
export const StudentHispanicEthnicityEnum = {
    Y: 'Y',
    N: 'N',
    Empty: ''
} as const;

export type StudentHispanicEthnicityEnum = typeof StudentHispanicEthnicityEnum[keyof typeof StudentHispanicEthnicityEnum];
export const StudentHomeLanguageEnum = {
    English: 'English',
    Albanian: 'Albanian',
    Amharic: 'Amharic',
    Arabic: 'Arabic',
    Bengali: 'Bengali',
    Bosnian: 'Bosnian',
    Burmese: 'Burmese',
    Cantonese: 'Cantonese',
    Chinese: 'Chinese',
    Dutch: 'Dutch',
    Farsi: 'Farsi',
    French: 'French',
    German: 'German',
    Hebrew: 'Hebrew',
    Hindi: 'Hindi',
    Hmong: 'Hmong',
    Ilocano: 'Ilocano',
    Japanese: 'Japanese',
    Javanese: 'Javanese',
    Karen: 'Karen',
    Khmer: 'Khmer',
    Korean: 'Korean',
    Laotian: 'Laotian',
    Latvian: 'Latvian',
    Malay: 'Malay',
    Mandarin: 'Mandarin',
    Nepali: 'Nepali',
    Oromo: 'Oromo',
    Polish: 'Polish',
    Portuguese: 'Portuguese',
    Punjabi: 'Punjabi',
    Romanian: 'Romanian',
    Russian: 'Russian',
    Samoan: 'Samoan',
    Serbian: 'Serbian',
    Somali: 'Somali',
    Spanish: 'Spanish',
    Swahili: 'Swahili',
    Tagalog: 'Tagalog',
    Tamil: 'Tamil',
    Telugu: 'Telugu',
    Thai: 'Thai',
    Tigrinya: 'Tigrinya',
    Turkish: 'Turkish',
    Ukrainian: 'Ukrainian',
    Urdu: 'Urdu',
    Vietnamese: 'Vietnamese',
    Empty: ''
} as const;

export type StudentHomeLanguageEnum = typeof StudentHomeLanguageEnum[keyof typeof StudentHomeLanguageEnum];
export const StudentRaceEnum = {
    Caucasian: 'Caucasian',
    Asian: 'Asian',
    BlackOrAfricanAmerican: 'Black or African American',
    AmericanIndian: 'American Indian',
    HawaiianOrOtherPacificIslander: 'Hawaiian or Other Pacific Islander',
    TwoOrMoreRaces: 'Two or More Races',
    Unknown: 'Unknown',
    Empty: ''
} as const;

export type StudentRaceEnum = typeof StudentRaceEnum[keyof typeof StudentRaceEnum];

/**
 * 
 * @export
 * @interface StudentObject
 */
export interface StudentObject {
    /**
     * 
     * @type {Student}
     * @memberof StudentObject
     */
    'object'?: Student;
}
/**
 * 
 * @export
 * @interface StudentResponse
 */
export interface StudentResponse {
    /**
     * 
     * @type {Student}
     * @memberof StudentResponse
     */
    'data'?: Student;
}
/**
 * 
 * @export
 * @interface StudentsCreated
 */
export interface StudentsCreated extends Event {
    /**
     * 
     * @type {StudentObject}
     * @memberof StudentsCreated
     */
    'data'?: StudentObject;
}
/**
 * 
 * @export
 * @interface StudentsCreatedAllOf
 */
export interface StudentsCreatedAllOf {
    /**
     * 
     * @type {StudentObject}
     * @memberof StudentsCreatedAllOf
     */
    'data'?: StudentObject;
}
/**
 * 
 * @export
 * @interface StudentsDeleted
 */
export interface StudentsDeleted extends Event {
    /**
     * 
     * @type {StudentObject}
     * @memberof StudentsDeleted
     */
    'data'?: StudentObject;
}
/**
 * 
 * @export
 * @interface StudentsResponse
 */
export interface StudentsResponse {
    /**
     * 
     * @type {Array<StudentResponse>}
     * @memberof StudentsResponse
     */
    'data'?: Array<StudentResponse>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof StudentsResponse
     */
    'links'?: Array<Link>;
}
/**
 * 
 * @export
 * @interface StudentsUpdated
 */
export interface StudentsUpdated extends Event {
    /**
     * 
     * @type {StudentObject}
     * @memberof StudentsUpdated
     */
    'data'?: StudentObject;
    /**
     * 
     * @type {object}
     * @memberof StudentsUpdated
     */
    'previous_attributes'?: object;
}
/**
 * 
 * @export
 * @interface StudentsUpdatedAllOf
 */
export interface StudentsUpdatedAllOf {
    /**
     * 
     * @type {StudentObject}
     * @memberof StudentsUpdatedAllOf
     */
    'data'?: StudentObject;
    /**
     * 
     * @type {object}
     * @memberof StudentsUpdatedAllOf
     */
    'previous_attributes'?: object;
}
/**
 * 
 * @export
 * @interface Teacher
 */
export interface Teacher {
    /**
     * 
     * @type {string}
     * @memberof Teacher
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Teacher
     */
    'created'?: string;
    /**
     * 
     * @type {Credentials}
     * @memberof Teacher
     */
    'credentials'?: Credentials;
    /**
     * 
     * @type {string}
     * @memberof Teacher
     */
    'district'?: string;
    /**
     * 
     * @type {string}
     * @memberof Teacher
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Teacher
     */
    'last_modified'?: string;
    /**
     * 
     * @type {Name}
     * @memberof Teacher
     */
    'name'?: Name;
    /**
     * 
     * @type {string}
     * @memberof Teacher
     */
    'school'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Teacher
     */
    'schools'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Teacher
     */
    'sis_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Teacher
     */
    'state_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Teacher
     */
    'teacher_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Teacher
     */
    'title'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof Teacher
     */
    'ext'?: object;
}
/**
 * 
 * @export
 * @interface TeacherObject
 */
export interface TeacherObject {
    /**
     * 
     * @type {Teacher}
     * @memberof TeacherObject
     */
    'object'?: Teacher;
}
/**
 * 
 * @export
 * @interface TeacherResponse
 */
export interface TeacherResponse {
    /**
     * 
     * @type {Teacher}
     * @memberof TeacherResponse
     */
    'data'?: Teacher;
}
/**
 * 
 * @export
 * @interface TeachersCreated
 */
export interface TeachersCreated extends Event {
    /**
     * 
     * @type {TeacherObject}
     * @memberof TeachersCreated
     */
    'data'?: TeacherObject;
}
/**
 * 
 * @export
 * @interface TeachersCreatedAllOf
 */
export interface TeachersCreatedAllOf {
    /**
     * 
     * @type {TeacherObject}
     * @memberof TeachersCreatedAllOf
     */
    'data'?: TeacherObject;
}
/**
 * 
 * @export
 * @interface TeachersDeleted
 */
export interface TeachersDeleted extends Event {
    /**
     * 
     * @type {TeacherObject}
     * @memberof TeachersDeleted
     */
    'data'?: TeacherObject;
}
/**
 * 
 * @export
 * @interface TeachersResponse
 */
export interface TeachersResponse {
    /**
     * 
     * @type {Array<TeacherResponse>}
     * @memberof TeachersResponse
     */
    'data'?: Array<TeacherResponse>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof TeachersResponse
     */
    'links'?: Array<Link>;
}
/**
 * 
 * @export
 * @interface TeachersUpdated
 */
export interface TeachersUpdated extends Event {
    /**
     * 
     * @type {TeacherObject}
     * @memberof TeachersUpdated
     */
    'data'?: TeacherObject;
    /**
     * 
     * @type {object}
     * @memberof TeachersUpdated
     */
    'previous_attributes'?: object;
}
/**
 * 
 * @export
 * @interface TeachersUpdatedAllOf
 */
export interface TeachersUpdatedAllOf {
    /**
     * 
     * @type {TeacherObject}
     * @memberof TeachersUpdatedAllOf
     */
    'data'?: TeacherObject;
    /**
     * 
     * @type {object}
     * @memberof TeachersUpdatedAllOf
     */
    'previous_attributes'?: object;
}
/**
 * 
 * @export
 * @interface Term
 */
export interface Term {
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'start_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'end_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'district'?: string;
}
/**
 * 
 * @export
 * @interface TermObject
 */
export interface TermObject {
    /**
     * 
     * @type {Term}
     * @memberof TermObject
     */
    'object'?: Term;
}
/**
 * 
 * @export
 * @interface TermResponse
 */
export interface TermResponse {
    /**
     * 
     * @type {Term}
     * @memberof TermResponse
     */
    'data'?: Term;
}
/**
 * 
 * @export
 * @interface TermsCreated
 */
export interface TermsCreated extends Event {
    /**
     * 
     * @type {TermObject}
     * @memberof TermsCreated
     */
    'data'?: TermObject;
}
/**
 * 
 * @export
 * @interface TermsCreatedAllOf
 */
export interface TermsCreatedAllOf {
    /**
     * 
     * @type {TermObject}
     * @memberof TermsCreatedAllOf
     */
    'data'?: TermObject;
}
/**
 * 
 * @export
 * @interface TermsDeleted
 */
export interface TermsDeleted extends Event {
    /**
     * 
     * @type {TermObject}
     * @memberof TermsDeleted
     */
    'data'?: TermObject;
}
/**
 * 
 * @export
 * @interface TermsResponse
 */
export interface TermsResponse {
    /**
     * 
     * @type {Array<TermResponse>}
     * @memberof TermsResponse
     */
    'data'?: Array<TermResponse>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof TermsResponse
     */
    'links'?: Array<Link>;
}
/**
 * 
 * @export
 * @interface TermsUpdated
 */
export interface TermsUpdated extends Event {
    /**
     * 
     * @type {TermObject}
     * @memberof TermsUpdated
     */
    'data'?: TermObject;
    /**
     * 
     * @type {object}
     * @memberof TermsUpdated
     */
    'previous_attributes'?: object;
}
/**
 * 
 * @export
 * @interface TermsUpdatedAllOf
 */
export interface TermsUpdatedAllOf {
    /**
     * 
     * @type {TermObject}
     * @memberof TermsUpdatedAllOf
     */
    'data'?: TermObject;
    /**
     * 
     * @type {object}
     * @memberof TermsUpdatedAllOf
     */
    'previous_attributes'?: object;
}

/**
 * ContactsApi - axios parameter creator
 * @export
 */
export const ContactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a specific student contact
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContact: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getContact', 'id', id)
            const localVarPath = `/contacts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of student contacts
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContacts: async (limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the district for a student contact
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForContact: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDistrictForContact', 'id', id)
            const localVarPath = `/contacts/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the students for a student contact
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForContact: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStudentsForContact', 'id', id)
            const localVarPath = `/contacts/{id}/students`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactsApi - functional programming interface
 * @export
 */
export const ContactsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a specific student contact
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContact(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContact(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of student contacts
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContacts(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContacts(limit, startingAfter, endingBefore, count, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the district for a student contact
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForContact(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrictResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistrictForContact(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the students for a student contact
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudentsForContact(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudentsForContact(id, limit, startingAfter, endingBefore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContactsApi - factory interface
 * @export
 */
export const ContactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactsApiFp(configuration)
    return {
        /**
         * Returns a specific student contact
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContact(id: string, options?: any): AxiosPromise<ContactResponse> {
            return localVarFp.getContact(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of student contacts
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContacts(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options?: any): AxiosPromise<ContactsResponse> {
            return localVarFp.getContacts(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the district for a student contact
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForContact(id: string, options?: any): AxiosPromise<DistrictResponse> {
            return localVarFp.getDistrictForContact(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the students for a student contact
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForContact(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<StudentsResponse> {
            return localVarFp.getStudentsForContact(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactsApi - object-oriented interface
 * @export
 * @class ContactsApi
 * @extends {BaseAPI}
 */
export class ContactsApi extends BaseAPI {
    /**
     * Returns a specific student contact
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public getContact(id: string, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).getContact(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of student contacts
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {'' | 'true' | 'false' | 'undefined'} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public getContacts(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).getContacts(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the district for a student contact
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public getDistrictForContact(id: string, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).getDistrictForContact(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the students for a student contact
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public getStudentsForContact(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).getStudentsForContact(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CoursesApi - axios parameter creator
 * @export
 */
export const CoursesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a specific course
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourse: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCourse', 'id', id)
            const localVarPath = `/courses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of courses
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourses: async (limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/courses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the district for a course
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForCourse: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDistrictForCourse', 'id', id)
            const localVarPath = `/courses/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the sections for a Courses
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForCourse: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSectionsForCourse', 'id', id)
            const localVarPath = `/courses/{id}/sections`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoursesApi - functional programming interface
 * @export
 */
export const CoursesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoursesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a specific course
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourse(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourse(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of courses
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourses(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoursesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourses(limit, startingAfter, endingBefore, count, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the district for a course
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForCourse(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrictResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistrictForCourse(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the sections for a Courses
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSectionsForCourse(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSectionsForCourse(id, limit, startingAfter, endingBefore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CoursesApi - factory interface
 * @export
 */
export const CoursesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoursesApiFp(configuration)
    return {
        /**
         * Returns a specific course
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourse(id: string, options?: any): AxiosPromise<CourseResponse> {
            return localVarFp.getCourse(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of courses
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourses(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options?: any): AxiosPromise<CoursesResponse> {
            return localVarFp.getCourses(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the district for a course
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForCourse(id: string, options?: any): AxiosPromise<DistrictResponse> {
            return localVarFp.getDistrictForCourse(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the sections for a Courses
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForCourse(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<SectionsResponse> {
            return localVarFp.getSectionsForCourse(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoursesApi - object-oriented interface
 * @export
 * @class CoursesApi
 * @extends {BaseAPI}
 */
export class CoursesApi extends BaseAPI {
    /**
     * Returns a specific course
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public getCourse(id: string, options?: AxiosRequestConfig) {
        return CoursesApiFp(this.configuration).getCourse(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of courses
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {'' | 'true' | 'false' | 'undefined'} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public getCourses(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options?: AxiosRequestConfig) {
        return CoursesApiFp(this.configuration).getCourses(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the district for a course
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public getDistrictForCourse(id: string, options?: AxiosRequestConfig) {
        return CoursesApiFp(this.configuration).getDistrictForCourse(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the sections for a Courses
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public getSectionsForCourse(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig) {
        return CoursesApiFp(this.configuration).getSectionsForCourse(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DistrictAdminsApi - axios parameter creator
 * @export
 */
export const DistrictAdminsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a specific district admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictAdmin: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDistrictAdmin', 'id', id)
            const localVarPath = `/district_admins/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of district admins
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictAdmins: async (limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/district_admins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the district for a district admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForDistrictAdmin: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDistrictForDistrictAdmin', 'id', id)
            const localVarPath = `/district_admins/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DistrictAdminsApi - functional programming interface
 * @export
 */
export const DistrictAdminsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DistrictAdminsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a specific district admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictAdmin(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrictAdminResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistrictAdmin(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of district admins
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictAdmins(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrictAdminsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistrictAdmins(limit, startingAfter, endingBefore, count, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the district for a district admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForDistrictAdmin(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrictResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistrictForDistrictAdmin(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DistrictAdminsApi - factory interface
 * @export
 */
export const DistrictAdminsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DistrictAdminsApiFp(configuration)
    return {
        /**
         * Returns a specific district admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictAdmin(id: string, options?: any): AxiosPromise<DistrictAdminResponse> {
            return localVarFp.getDistrictAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of district admins
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictAdmins(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options?: any): AxiosPromise<DistrictAdminsResponse> {
            return localVarFp.getDistrictAdmins(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the district for a district admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForDistrictAdmin(id: string, options?: any): AxiosPromise<DistrictResponse> {
            return localVarFp.getDistrictForDistrictAdmin(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DistrictAdminsApi - object-oriented interface
 * @export
 * @class DistrictAdminsApi
 * @extends {BaseAPI}
 */
export class DistrictAdminsApi extends BaseAPI {
    /**
     * Returns a specific district admin
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictAdminsApi
     */
    public getDistrictAdmin(id: string, options?: AxiosRequestConfig) {
        return DistrictAdminsApiFp(this.configuration).getDistrictAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of district admins
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {'' | 'true' | 'false' | 'undefined'} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictAdminsApi
     */
    public getDistrictAdmins(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options?: AxiosRequestConfig) {
        return DistrictAdminsApiFp(this.configuration).getDistrictAdmins(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the district for a district admin
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictAdminsApi
     */
    public getDistrictForDistrictAdmin(id: string, options?: AxiosRequestConfig) {
        return DistrictAdminsApiFp(this.configuration).getDistrictForDistrictAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DistrictsApi - axios parameter creator
 * @export
 */
export const DistrictsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a specific district
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrict: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDistrict', 'id', id)
            const localVarPath = `/districts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of districts. In practice this will only return the one district associated with the bearer token
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistricts: async (count?: '' | 'true' | 'false' | 'undefined', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/districts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DistrictsApi - functional programming interface
 * @export
 */
export const DistrictsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DistrictsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a specific district
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrict(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrictResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistrict(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of districts. In practice this will only return the one district associated with the bearer token
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistricts(count?: '' | 'true' | 'false' | 'undefined', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrictsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistricts(count, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DistrictsApi - factory interface
 * @export
 */
export const DistrictsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DistrictsApiFp(configuration)
    return {
        /**
         * Returns a specific district
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrict(id: string, options?: any): AxiosPromise<DistrictResponse> {
            return localVarFp.getDistrict(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of districts. In practice this will only return the one district associated with the bearer token
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistricts(count?: '' | 'true' | 'false' | 'undefined', options?: any): AxiosPromise<DistrictsResponse> {
            return localVarFp.getDistricts(count, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DistrictsApi - object-oriented interface
 * @export
 * @class DistrictsApi
 * @extends {BaseAPI}
 */
export class DistrictsApi extends BaseAPI {
    /**
     * Returns a specific district
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictsApi
     */
    public getDistrict(id: string, options?: AxiosRequestConfig) {
        return DistrictsApiFp(this.configuration).getDistrict(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of districts. In practice this will only return the one district associated with the bearer token
     * @param {'' | 'true' | 'false' | 'undefined'} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictsApi
     */
    public getDistricts(count?: '' | 'true' | 'false' | 'undefined', options?: AxiosRequestConfig) {
        return DistrictsApiFp(this.configuration).getDistricts(count, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the specific event
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEvent', 'id', id)
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of events
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {string} [school] 
         * @param {Array<string>} [recordType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (limit?: number, startingAfter?: string, endingBefore?: string, school?: string, recordType?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (school !== undefined) {
                localVarQueryParameter['school'] = school;
            }

            if (recordType) {
                localVarQueryParameter['record_type'] = recordType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the specific event
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvent(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvent(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of events
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {string} [school] 
         * @param {Array<string>} [recordType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(limit?: number, startingAfter?: string, endingBefore?: string, school?: string, recordType?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(limit, startingAfter, endingBefore, school, recordType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * Returns the specific event
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(id: string, options?: any): AxiosPromise<EventResponse> {
            return localVarFp.getEvent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of events
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {string} [school] 
         * @param {Array<string>} [recordType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(limit?: number, startingAfter?: string, endingBefore?: string, school?: string, recordType?: Array<string>, options?: any): AxiosPromise<EventsResponse> {
            return localVarFp.getEvents(limit, startingAfter, endingBefore, school, recordType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * Returns the specific event
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEvent(id: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEvent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of events
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {string} [school] 
     * @param {Array<string>} [recordType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEvents(limit?: number, startingAfter?: string, endingBefore?: string, school?: string, recordType?: Array<string>, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEvents(limit, startingAfter, endingBefore, school, recordType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SchoolAdminsApi - axios parameter creator
 * @export
 */
export const SchoolAdminsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the district for a school admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForSchoolAdmin: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDistrictForSchoolAdmin', 'id', id)
            const localVarPath = `/school_admins/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific school admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolAdmin: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSchoolAdmin', 'id', id)
            const localVarPath = `/school_admins/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of school admins
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolAdmins: async (limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/school_admins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the schools for a school admin
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolsForSchoolAdmin: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSchoolsForSchoolAdmin', 'id', id)
            const localVarPath = `/school_admins/{id}/schools`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchoolAdminsApi - functional programming interface
 * @export
 */
export const SchoolAdminsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchoolAdminsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the district for a school admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForSchoolAdmin(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrictResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistrictForSchoolAdmin(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific school admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolAdmin(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolAdminResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchoolAdmin(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of school admins
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolAdmins(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolAdminsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchoolAdmins(limit, startingAfter, endingBefore, count, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the schools for a school admin
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolsForSchoolAdmin(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchoolsForSchoolAdmin(id, limit, startingAfter, endingBefore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SchoolAdminsApi - factory interface
 * @export
 */
export const SchoolAdminsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchoolAdminsApiFp(configuration)
    return {
        /**
         * Returns the district for a school admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForSchoolAdmin(id: string, options?: any): AxiosPromise<DistrictResponse> {
            return localVarFp.getDistrictForSchoolAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific school admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolAdmin(id: string, options?: any): AxiosPromise<SchoolAdminResponse> {
            return localVarFp.getSchoolAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of school admins
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolAdmins(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options?: any): AxiosPromise<SchoolAdminsResponse> {
            return localVarFp.getSchoolAdmins(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the schools for a school admin
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolsForSchoolAdmin(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<SchoolsResponse> {
            return localVarFp.getSchoolsForSchoolAdmin(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchoolAdminsApi - object-oriented interface
 * @export
 * @class SchoolAdminsApi
 * @extends {BaseAPI}
 */
export class SchoolAdminsApi extends BaseAPI {
    /**
     * Returns the district for a school admin
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolAdminsApi
     */
    public getDistrictForSchoolAdmin(id: string, options?: AxiosRequestConfig) {
        return SchoolAdminsApiFp(this.configuration).getDistrictForSchoolAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific school admin
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolAdminsApi
     */
    public getSchoolAdmin(id: string, options?: AxiosRequestConfig) {
        return SchoolAdminsApiFp(this.configuration).getSchoolAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of school admins
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {'' | 'true' | 'false' | 'undefined'} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolAdminsApi
     */
    public getSchoolAdmins(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options?: AxiosRequestConfig) {
        return SchoolAdminsApiFp(this.configuration).getSchoolAdmins(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the schools for a school admin
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolAdminsApi
     */
    public getSchoolsForSchoolAdmin(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig) {
        return SchoolAdminsApiFp(this.configuration).getSchoolsForSchoolAdmin(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SchoolsApi - axios parameter creator
 * @export
 */
export const SchoolsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the district for a school
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForSchool: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDistrictForSchool', 'id', id)
            const localVarPath = `/schools/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific school
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchool: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSchool', 'id', id)
            const localVarPath = `/schools/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of schools
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchools: async (limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/schools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the sections for a school
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForSchool: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSectionsForSchool', 'id', id)
            const localVarPath = `/schools/{id}/sections`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the students for a school
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForSchool: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStudentsForSchool', 'id', id)
            const localVarPath = `/schools/{id}/students`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the teachers for a school
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachersForSchool: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTeachersForSchool', 'id', id)
            const localVarPath = `/schools/{id}/teachers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchoolsApi - functional programming interface
 * @export
 */
export const SchoolsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchoolsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the district for a school
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForSchool(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrictResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistrictForSchool(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific school
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchool(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchool(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of schools
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchools(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchools(limit, startingAfter, endingBefore, count, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the sections for a school
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSectionsForSchool(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSectionsForSchool(id, limit, startingAfter, endingBefore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the students for a school
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudentsForSchool(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudentsForSchool(id, limit, startingAfter, endingBefore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the teachers for a school
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeachersForSchool(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeachersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeachersForSchool(id, limit, startingAfter, endingBefore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SchoolsApi - factory interface
 * @export
 */
export const SchoolsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchoolsApiFp(configuration)
    return {
        /**
         * Returns the district for a school
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForSchool(id: string, options?: any): AxiosPromise<DistrictResponse> {
            return localVarFp.getDistrictForSchool(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific school
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchool(id: string, options?: any): AxiosPromise<SchoolResponse> {
            return localVarFp.getSchool(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of schools
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchools(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options?: any): AxiosPromise<SchoolsResponse> {
            return localVarFp.getSchools(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the sections for a school
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForSchool(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<SectionsResponse> {
            return localVarFp.getSectionsForSchool(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the students for a school
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForSchool(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<StudentsResponse> {
            return localVarFp.getStudentsForSchool(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the teachers for a school
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachersForSchool(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<TeachersResponse> {
            return localVarFp.getTeachersForSchool(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchoolsApi - object-oriented interface
 * @export
 * @class SchoolsApi
 * @extends {BaseAPI}
 */
export class SchoolsApi extends BaseAPI {
    /**
     * Returns the district for a school
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolsApi
     */
    public getDistrictForSchool(id: string, options?: AxiosRequestConfig) {
        return SchoolsApiFp(this.configuration).getDistrictForSchool(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific school
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolsApi
     */
    public getSchool(id: string, options?: AxiosRequestConfig) {
        return SchoolsApiFp(this.configuration).getSchool(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of schools
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {'' | 'true' | 'false' | 'undefined'} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolsApi
     */
    public getSchools(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options?: AxiosRequestConfig) {
        return SchoolsApiFp(this.configuration).getSchools(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the sections for a school
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolsApi
     */
    public getSectionsForSchool(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig) {
        return SchoolsApiFp(this.configuration).getSectionsForSchool(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the students for a school
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolsApi
     */
    public getStudentsForSchool(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig) {
        return SchoolsApiFp(this.configuration).getStudentsForSchool(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the teachers for a school
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolsApi
     */
    public getTeachersForSchool(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig) {
        return SchoolsApiFp(this.configuration).getTeachersForSchool(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SectionsApi - axios parameter creator
 * @export
 */
export const SectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the course for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseForSection: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCourseForSection', 'id', id)
            const localVarPath = `/sections/{id}/course`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the district for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForSection: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDistrictForSection', 'id', id)
            const localVarPath = `/sections/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the school for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolForSection: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSchoolForSection', 'id', id)
            const localVarPath = `/sections/{id}/school`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSection: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSection', 'id', id)
            const localVarPath = `/sections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of sections
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSections: async (limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the students for a section
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForSection: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStudentsForSection', 'id', id)
            const localVarPath = `/sections/{id}/students`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the primary teacher for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeacherForSection: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTeacherForSection', 'id', id)
            const localVarPath = `/sections/{id}/teacher`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the teachers for a section
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachersForSection: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTeachersForSection', 'id', id)
            const localVarPath = `/sections/{id}/teachers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the term for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTermForSection: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTermForSection', 'id', id)
            const localVarPath = `/sections/{id}/term`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SectionsApi - functional programming interface
 * @export
 */
export const SectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the course for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseForSection(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseForSection(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the district for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForSection(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrictResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistrictForSection(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the school for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolForSection(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchoolForSection(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSection(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSection(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of sections
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSections(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSections(limit, startingAfter, endingBefore, count, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the students for a section
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudentsForSection(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudentsForSection(id, limit, startingAfter, endingBefore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the primary teacher for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeacherForSection(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeacherResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeacherForSection(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the teachers for a section
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeachersForSection(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeachersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeachersForSection(id, limit, startingAfter, endingBefore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the term for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTermForSection(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TermResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTermForSection(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SectionsApi - factory interface
 * @export
 */
export const SectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SectionsApiFp(configuration)
    return {
        /**
         * Returns the course for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseForSection(id: string, options?: any): AxiosPromise<CourseResponse> {
            return localVarFp.getCourseForSection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the district for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForSection(id: string, options?: any): AxiosPromise<DistrictResponse> {
            return localVarFp.getDistrictForSection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the school for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolForSection(id: string, options?: any): AxiosPromise<SchoolResponse> {
            return localVarFp.getSchoolForSection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSection(id: string, options?: any): AxiosPromise<SectionResponse> {
            return localVarFp.getSection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of sections
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSections(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options?: any): AxiosPromise<SectionsResponse> {
            return localVarFp.getSections(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the students for a section
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForSection(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<StudentsResponse> {
            return localVarFp.getStudentsForSection(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the primary teacher for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeacherForSection(id: string, options?: any): AxiosPromise<TeacherResponse> {
            return localVarFp.getTeacherForSection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the teachers for a section
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachersForSection(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<TeachersResponse> {
            return localVarFp.getTeachersForSection(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the term for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTermForSection(id: string, options?: any): AxiosPromise<TermResponse> {
            return localVarFp.getTermForSection(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SectionsApi - object-oriented interface
 * @export
 * @class SectionsApi
 * @extends {BaseAPI}
 */
export class SectionsApi extends BaseAPI {
    /**
     * Returns the course for a section
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    public getCourseForSection(id: string, options?: AxiosRequestConfig) {
        return SectionsApiFp(this.configuration).getCourseForSection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the district for a section
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    public getDistrictForSection(id: string, options?: AxiosRequestConfig) {
        return SectionsApiFp(this.configuration).getDistrictForSection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the school for a section
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    public getSchoolForSection(id: string, options?: AxiosRequestConfig) {
        return SectionsApiFp(this.configuration).getSchoolForSection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific section
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    public getSection(id: string, options?: AxiosRequestConfig) {
        return SectionsApiFp(this.configuration).getSection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of sections
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {'' | 'true' | 'false' | 'undefined'} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    public getSections(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options?: AxiosRequestConfig) {
        return SectionsApiFp(this.configuration).getSections(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the students for a section
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    public getStudentsForSection(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig) {
        return SectionsApiFp(this.configuration).getStudentsForSection(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the primary teacher for a section
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    public getTeacherForSection(id: string, options?: AxiosRequestConfig) {
        return SectionsApiFp(this.configuration).getTeacherForSection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the teachers for a section
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    public getTeachersForSection(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig) {
        return SectionsApiFp(this.configuration).getTeachersForSection(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the term for a section
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    public getTermForSection(id: string, options?: AxiosRequestConfig) {
        return SectionsApiFp(this.configuration).getTermForSection(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StudentsApi - axios parameter creator
 * @export
 */
export const StudentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the contacts for a student
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactsForStudent: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getContactsForStudent', 'id', id)
            const localVarPath = `/students/{id}/contacts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the district for a student
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForStudent: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDistrictForStudent', 'id', id)
            const localVarPath = `/students/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the primary school for a student
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolForStudent: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSchoolForStudent', 'id', id)
            const localVarPath = `/students/{id}/school`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the schools for a student
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolsForStudent: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSchoolsForStudent', 'id', id)
            const localVarPath = `/students/{id}/schools`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the sections for a student
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForStudent: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSectionsForStudent', 'id', id)
            const localVarPath = `/students/{id}/sections`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific student
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudent: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStudent', 'id', id)
            const localVarPath = `/students/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of students
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudents: async (limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/students`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the teachers for a student
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachersForStudent: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTeachersForStudent', 'id', id)
            const localVarPath = `/students/{id}/teachers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudentsApi - functional programming interface
 * @export
 */
export const StudentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the contacts for a student
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContactsForStudent(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContactsForStudent(id, limit, startingAfter, endingBefore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the district for a student
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForStudent(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrictResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistrictForStudent(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the primary school for a student
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolForStudent(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchoolForStudent(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the schools for a student
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolsForStudent(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchoolsForStudent(id, limit, startingAfter, endingBefore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the sections for a student
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSectionsForStudent(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSectionsForStudent(id, limit, startingAfter, endingBefore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific student
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudent(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudent(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of students
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudents(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudents(limit, startingAfter, endingBefore, count, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the teachers for a student
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeachersForStudent(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeachersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeachersForStudent(id, limit, startingAfter, endingBefore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StudentsApi - factory interface
 * @export
 */
export const StudentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudentsApiFp(configuration)
    return {
        /**
         * Returns the contacts for a student
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactsForStudent(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<ContactsResponse> {
            return localVarFp.getContactsForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the district for a student
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForStudent(id: string, options?: any): AxiosPromise<DistrictResponse> {
            return localVarFp.getDistrictForStudent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the primary school for a student
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolForStudent(id: string, options?: any): AxiosPromise<SchoolResponse> {
            return localVarFp.getSchoolForStudent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the schools for a student
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolsForStudent(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<SchoolsResponse> {
            return localVarFp.getSchoolsForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the sections for a student
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForStudent(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<SectionsResponse> {
            return localVarFp.getSectionsForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific student
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudent(id: string, options?: any): AxiosPromise<StudentResponse> {
            return localVarFp.getStudent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of students
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudents(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options?: any): AxiosPromise<StudentsResponse> {
            return localVarFp.getStudents(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the teachers for a student
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachersForStudent(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<TeachersResponse> {
            return localVarFp.getTeachersForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudentsApi - object-oriented interface
 * @export
 * @class StudentsApi
 * @extends {BaseAPI}
 */
export class StudentsApi extends BaseAPI {
    /**
     * Returns the contacts for a student
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public getContactsForStudent(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig) {
        return StudentsApiFp(this.configuration).getContactsForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the district for a student
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public getDistrictForStudent(id: string, options?: AxiosRequestConfig) {
        return StudentsApiFp(this.configuration).getDistrictForStudent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the primary school for a student
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public getSchoolForStudent(id: string, options?: AxiosRequestConfig) {
        return StudentsApiFp(this.configuration).getSchoolForStudent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the schools for a student
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public getSchoolsForStudent(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig) {
        return StudentsApiFp(this.configuration).getSchoolsForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the sections for a student
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public getSectionsForStudent(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig) {
        return StudentsApiFp(this.configuration).getSectionsForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific student
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public getStudent(id: string, options?: AxiosRequestConfig) {
        return StudentsApiFp(this.configuration).getStudent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of students
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {'' | 'true' | 'false' | 'undefined'} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public getStudents(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options?: AxiosRequestConfig) {
        return StudentsApiFp(this.configuration).getStudents(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the teachers for a student
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public getTeachersForStudent(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig) {
        return StudentsApiFp(this.configuration).getTeachersForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TeachersApi - axios parameter creator
 * @export
 */
export const TeachersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the district for a teacher
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForTeacher: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDistrictForTeacher', 'id', id)
            const localVarPath = `/teachers/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves school info for a teacher.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolForTeacher: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSchoolForTeacher', 'id', id)
            const localVarPath = `/teachers/{id}/school`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the schools for a teacher
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolsForTeacher: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSchoolsForTeacher', 'id', id)
            const localVarPath = `/teachers/{id}/schools`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the sections for a teacher
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForTeacher: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSectionsForTeacher', 'id', id)
            const localVarPath = `/teachers/{id}/sections`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the students for a teacher
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForTeacher: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStudentsForTeacher', 'id', id)
            const localVarPath = `/teachers/{id}/students`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific teacher
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeacher: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTeacher', 'id', id)
            const localVarPath = `/teachers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of teachers
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachers: async (limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/teachers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeachersApi - functional programming interface
 * @export
 */
export const TeachersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeachersApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the district for a teacher
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForTeacher(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrictResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistrictForTeacher(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves school info for a teacher.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolForTeacher(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchoolForTeacher(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the schools for a teacher
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolsForTeacher(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchoolsForTeacher(id, limit, startingAfter, endingBefore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the sections for a teacher
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSectionsForTeacher(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSectionsForTeacher(id, limit, startingAfter, endingBefore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the students for a teacher
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudentsForTeacher(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudentsForTeacher(id, limit, startingAfter, endingBefore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific teacher
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeacher(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeacherResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeacher(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of teachers
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeachers(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeachersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeachers(limit, startingAfter, endingBefore, count, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TeachersApi - factory interface
 * @export
 */
export const TeachersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeachersApiFp(configuration)
    return {
        /**
         * Returns the district for a teacher
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForTeacher(id: string, options?: any): AxiosPromise<DistrictResponse> {
            return localVarFp.getDistrictForTeacher(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves school info for a teacher.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolForTeacher(id: string, options?: any): AxiosPromise<SchoolResponse> {
            return localVarFp.getSchoolForTeacher(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the schools for a teacher
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolsForTeacher(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<SchoolsResponse> {
            return localVarFp.getSchoolsForTeacher(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the sections for a teacher
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForTeacher(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<SectionsResponse> {
            return localVarFp.getSectionsForTeacher(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the students for a teacher
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForTeacher(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<StudentsResponse> {
            return localVarFp.getStudentsForTeacher(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific teacher
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeacher(id: string, options?: any): AxiosPromise<TeacherResponse> {
            return localVarFp.getTeacher(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of teachers
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachers(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options?: any): AxiosPromise<TeachersResponse> {
            return localVarFp.getTeachers(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeachersApi - object-oriented interface
 * @export
 * @class TeachersApi
 * @extends {BaseAPI}
 */
export class TeachersApi extends BaseAPI {
    /**
     * Returns the district for a teacher
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public getDistrictForTeacher(id: string, options?: AxiosRequestConfig) {
        return TeachersApiFp(this.configuration).getDistrictForTeacher(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves school info for a teacher.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public getSchoolForTeacher(id: string, options?: AxiosRequestConfig) {
        return TeachersApiFp(this.configuration).getSchoolForTeacher(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the schools for a teacher
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public getSchoolsForTeacher(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig) {
        return TeachersApiFp(this.configuration).getSchoolsForTeacher(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the sections for a teacher
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public getSectionsForTeacher(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig) {
        return TeachersApiFp(this.configuration).getSectionsForTeacher(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the students for a teacher
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public getStudentsForTeacher(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig) {
        return TeachersApiFp(this.configuration).getStudentsForTeacher(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific teacher
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public getTeacher(id: string, options?: AxiosRequestConfig) {
        return TeachersApiFp(this.configuration).getTeacher(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of teachers
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {'' | 'true' | 'false' | 'undefined'} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public getTeachers(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options?: AxiosRequestConfig) {
        return TeachersApiFp(this.configuration).getTeachers(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TermsApi - axios parameter creator
 * @export
 */
export const TermsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the district for a term
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForTerm: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDistrictForTerm', 'id', id)
            const localVarPath = `/terms/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the sections for a term
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForTerm: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSectionsForTerm', 'id', id)
            const localVarPath = `/terms/{id}/sections`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific term
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerm: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTerm', 'id', id)
            const localVarPath = `/terms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of terms
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerms: async (limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/terms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TermsApi - functional programming interface
 * @export
 */
export const TermsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TermsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the district for a term
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForTerm(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrictResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistrictForTerm(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the sections for a term
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSectionsForTerm(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSectionsForTerm(id, limit, startingAfter, endingBefore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific term
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTerm(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TermResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTerm(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of terms
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTerms(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TermsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTerms(limit, startingAfter, endingBefore, count, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TermsApi - factory interface
 * @export
 */
export const TermsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TermsApiFp(configuration)
    return {
        /**
         * Returns the district for a term
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForTerm(id: string, options?: any): AxiosPromise<DistrictResponse> {
            return localVarFp.getDistrictForTerm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the sections for a term
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForTerm(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<SectionsResponse> {
            return localVarFp.getSectionsForTerm(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific term
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerm(id: string, options?: any): AxiosPromise<TermResponse> {
            return localVarFp.getTerm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of terms
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true' | 'false' | 'undefined'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerms(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options?: any): AxiosPromise<TermsResponse> {
            return localVarFp.getTerms(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TermsApi - object-oriented interface
 * @export
 * @class TermsApi
 * @extends {BaseAPI}
 */
export class TermsApi extends BaseAPI {
    /**
     * Returns the district for a term
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermsApi
     */
    public getDistrictForTerm(id: string, options?: AxiosRequestConfig) {
        return TermsApiFp(this.configuration).getDistrictForTerm(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the sections for a term
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermsApi
     */
    public getSectionsForTerm(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: AxiosRequestConfig) {
        return TermsApiFp(this.configuration).getSectionsForTerm(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific term
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermsApi
     */
    public getTerm(id: string, options?: AxiosRequestConfig) {
        return TermsApiFp(this.configuration).getTerm(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of terms
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {'' | 'true' | 'false' | 'undefined'} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermsApi
     */
    public getTerms(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true' | 'false' | 'undefined', options?: AxiosRequestConfig) {
        return TermsApiFp(this.configuration).getTerms(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }
}


