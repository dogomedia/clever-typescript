// tslint:disable
/**
 * Data API
 * Serves the Clever Data API
 *
 * The version of the OpenAPI document: 2.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AdminName
 */
export interface AdminName {
    /**
     * 
     * @type {string}
     * @memberof AdminName
     */
    first?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AdminName
     */
    last?: string | null;
}
/**
 * 
 * @export
 * @interface BadRequest
 */
export interface BadRequest {
    /**
     * 
     * @type {string}
     * @memberof BadRequest
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface Contact
 */
export interface Contact {
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    district?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    email?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    phone?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    phone_type?: ContactPhoneTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    relationship?: ContactRelationshipEnum;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    sis_id?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Contact
     */
    students?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    type?: ContactTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ContactPhoneTypeEnum {
    Cell = 'Cell',
    Home = 'Home',
    Work = 'Work',
    Other = 'Other',
    Empty = ''
}
/**
    * @export
    * @enum {string}
    */
export enum ContactRelationshipEnum {
    Parent = 'Parent',
    Grandparent = 'Grandparent',
    Self = 'Self',
    AuntUncle = 'Aunt/Uncle',
    Sibling = 'Sibling',
    Other = 'Other',
    Empty = ''
}
/**
    * @export
    * @enum {string}
    */
export enum ContactTypeEnum {
    ParentGuardian = 'Parent/Guardian',
    Emergency = 'Emergency',
    Primary = 'Primary',
    Secondary = 'Secondary',
    Family = 'Family',
    Other = 'Other',
    Empty = ''
}

/**
 * 
 * @export
 * @interface ContactObject
 */
export interface ContactObject {
    /**
     * 
     * @type {Contact}
     * @memberof ContactObject
     */
    object?: Contact;
}
/**
 * 
 * @export
 * @interface ContactResponse
 */
export interface ContactResponse {
    /**
     * 
     * @type {Contact}
     * @memberof ContactResponse
     */
    data?: Contact;
}
/**
 * 
 * @export
 * @interface ContactsCreated
 */
export interface ContactsCreated extends Event {
    /**
     * 
     * @type {ContactObject}
     * @memberof ContactsCreated
     */
    data?: ContactObject;
}
/**
 * 
 * @export
 * @interface ContactsCreatedAllOf
 */
export interface ContactsCreatedAllOf {
    /**
     * 
     * @type {ContactObject}
     * @memberof ContactsCreatedAllOf
     */
    data?: ContactObject;
}
/**
 * 
 * @export
 * @interface ContactsDeleted
 */
export interface ContactsDeleted extends Event {
    /**
     * 
     * @type {ContactObject}
     * @memberof ContactsDeleted
     */
    data?: ContactObject;
}
/**
 * 
 * @export
 * @interface ContactsResponse
 */
export interface ContactsResponse {
    /**
     * 
     * @type {Array<ContactResponse>}
     * @memberof ContactsResponse
     */
    data?: Array<ContactResponse>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof ContactsResponse
     */
    links?: Array<Link>;
}
/**
 * 
 * @export
 * @interface ContactsUpdated
 */
export interface ContactsUpdated extends Event {
    /**
     * 
     * @type {ContactObject}
     * @memberof ContactsUpdated
     */
    data?: ContactObject;
    /**
     * 
     * @type {object}
     * @memberof ContactsUpdated
     */
    previous_attributes?: object;
}
/**
 * 
 * @export
 * @interface ContactsUpdatedAllOf
 */
export interface ContactsUpdatedAllOf {
    /**
     * 
     * @type {ContactObject}
     * @memberof ContactsUpdatedAllOf
     */
    data?: ContactObject;
    /**
     * 
     * @type {object}
     * @memberof ContactsUpdatedAllOf
     */
    previous_attributes?: object;
}
/**
 * 
 * @export
 * @interface Course
 */
export interface Course {
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    number?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    district?: string;
}
/**
 * 
 * @export
 * @interface CourseObject
 */
export interface CourseObject {
    /**
     * 
     * @type {Course}
     * @memberof CourseObject
     */
    object?: Course;
}
/**
 * 
 * @export
 * @interface CourseResponse
 */
export interface CourseResponse {
    /**
     * 
     * @type {Course}
     * @memberof CourseResponse
     */
    data?: Course;
}
/**
 * 
 * @export
 * @interface CoursesCreated
 */
export interface CoursesCreated extends Event {
    /**
     * 
     * @type {CourseObject}
     * @memberof CoursesCreated
     */
    data?: CourseObject;
}
/**
 * 
 * @export
 * @interface CoursesCreatedAllOf
 */
export interface CoursesCreatedAllOf {
    /**
     * 
     * @type {CourseObject}
     * @memberof CoursesCreatedAllOf
     */
    data?: CourseObject;
}
/**
 * 
 * @export
 * @interface CoursesDeleted
 */
export interface CoursesDeleted extends Event {
    /**
     * 
     * @type {CourseObject}
     * @memberof CoursesDeleted
     */
    data?: CourseObject;
}
/**
 * 
 * @export
 * @interface CoursesResponse
 */
export interface CoursesResponse {
    /**
     * 
     * @type {Array<CourseResponse>}
     * @memberof CoursesResponse
     */
    data?: Array<CourseResponse>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof CoursesResponse
     */
    links?: Array<Link>;
}
/**
 * 
 * @export
 * @interface CoursesUpdated
 */
export interface CoursesUpdated extends Event {
    /**
     * 
     * @type {CourseObject}
     * @memberof CoursesUpdated
     */
    data?: CourseObject;
    /**
     * 
     * @type {object}
     * @memberof CoursesUpdated
     */
    previous_attributes?: object;
}
/**
 * 
 * @export
 * @interface CoursesUpdatedAllOf
 */
export interface CoursesUpdatedAllOf {
    /**
     * 
     * @type {CourseObject}
     * @memberof CoursesUpdatedAllOf
     */
    data?: CourseObject;
    /**
     * 
     * @type {object}
     * @memberof CoursesUpdatedAllOf
     */
    previous_attributes?: object;
}
/**
 * 
 * @export
 * @interface Credentials
 */
export interface Credentials {
    /**
     * 
     * @type {string}
     * @memberof Credentials
     */
    district_username?: string;
}
/**
 * 
 * @export
 * @interface District
 */
export interface District {
    /**
     * 
     * @type {string}
     * @memberof District
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof District
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof District
     */
    mdr_number?: string | null;
    /**
     * 
     * @type {string}
     * @memberof District
     */
    nces_id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof District
     */
    sis_type?: string;
    /**
     * 
     * @type {string}
     * @memberof District
     */
    state?: DistrictStateEnum;
    /**
     * 
     * @type {string}
     * @memberof District
     */
    last_sync?: string | null;
    /**
     * 
     * @type {string}
     * @memberof District
     */
    error?: string;
    /**
     * 
     * @type {string}
     * @memberof District
     */
    pause_start?: string | null;
    /**
     * 
     * @type {string}
     * @memberof District
     */
    pause_end?: string | null;
    /**
     * 
     * @type {string}
     * @memberof District
     */
    launch_date?: string;
    /**
     * 
     * @type {string}
     * @memberof District
     */
    portal_url?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof District
     */
    login_methods?: Array<string>;
    /**
     * 
     * @type {DistrictAdmin}
     * @memberof District
     */
    district_contact?: DistrictAdmin;
}

/**
    * @export
    * @enum {string}
    */
export enum DistrictStateEnum {
    Running = 'running',
    Pending = 'pending',
    Error = 'error',
    Paused = 'paused',
    Empty = ''
}

/**
 * 
 * @export
 * @interface DistrictAdmin
 */
export interface DistrictAdmin {
    /**
     * 
     * @type {string}
     * @memberof DistrictAdmin
     */
    id?: string;
    /**
     * 
     * @type {AdminName}
     * @memberof DistrictAdmin
     */
    name?: AdminName;
    /**
     * 
     * @type {string}
     * @memberof DistrictAdmin
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof DistrictAdmin
     */
    title?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DistrictAdmin
     */
    district?: string;
}
/**
 * 
 * @export
 * @interface DistrictAdminObject
 */
export interface DistrictAdminObject {
    /**
     * 
     * @type {DistrictAdmin}
     * @memberof DistrictAdminObject
     */
    object?: DistrictAdmin;
}
/**
 * 
 * @export
 * @interface DistrictAdminResponse
 */
export interface DistrictAdminResponse {
    /**
     * 
     * @type {DistrictAdmin}
     * @memberof DistrictAdminResponse
     */
    data?: DistrictAdmin;
}
/**
 * 
 * @export
 * @interface DistrictAdminsResponse
 */
export interface DistrictAdminsResponse {
    /**
     * 
     * @type {Array<DistrictAdminResponse>}
     * @memberof DistrictAdminsResponse
     */
    data?: Array<DistrictAdminResponse>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof DistrictAdminsResponse
     */
    links?: Array<Link>;
}
/**
 * 
 * @export
 * @interface DistrictObject
 */
export interface DistrictObject {
    /**
     * 
     * @type {District}
     * @memberof DistrictObject
     */
    object?: District;
}
/**
 * 
 * @export
 * @interface DistrictResponse
 */
export interface DistrictResponse {
    /**
     * 
     * @type {District}
     * @memberof DistrictResponse
     */
    data?: District;
}
/**
 * 
 * @export
 * @interface DistrictadminsCreated
 */
export interface DistrictadminsCreated extends Event {
    /**
     * 
     * @type {DistrictAdminObject}
     * @memberof DistrictadminsCreated
     */
    data?: DistrictAdminObject;
}
/**
 * 
 * @export
 * @interface DistrictadminsCreatedAllOf
 */
export interface DistrictadminsCreatedAllOf {
    /**
     * 
     * @type {DistrictAdminObject}
     * @memberof DistrictadminsCreatedAllOf
     */
    data?: DistrictAdminObject;
}
/**
 * 
 * @export
 * @interface DistrictadminsDeleted
 */
export interface DistrictadminsDeleted extends Event {
    /**
     * 
     * @type {DistrictAdminObject}
     * @memberof DistrictadminsDeleted
     */
    data?: DistrictAdminObject;
}
/**
 * 
 * @export
 * @interface DistrictadminsUpdated
 */
export interface DistrictadminsUpdated extends Event {
    /**
     * 
     * @type {DistrictAdminObject}
     * @memberof DistrictadminsUpdated
     */
    data?: DistrictAdminObject;
    /**
     * 
     * @type {object}
     * @memberof DistrictadminsUpdated
     */
    previous_attributes?: object;
}
/**
 * 
 * @export
 * @interface DistrictadminsUpdatedAllOf
 */
export interface DistrictadminsUpdatedAllOf {
    /**
     * 
     * @type {DistrictAdminObject}
     * @memberof DistrictadminsUpdatedAllOf
     */
    data?: DistrictAdminObject;
    /**
     * 
     * @type {object}
     * @memberof DistrictadminsUpdatedAllOf
     */
    previous_attributes?: object;
}
/**
 * 
 * @export
 * @interface DistrictsCreated
 */
export interface DistrictsCreated extends Event {
    /**
     * 
     * @type {DistrictObject}
     * @memberof DistrictsCreated
     */
    data?: DistrictObject;
}
/**
 * 
 * @export
 * @interface DistrictsCreatedAllOf
 */
export interface DistrictsCreatedAllOf {
    /**
     * 
     * @type {DistrictObject}
     * @memberof DistrictsCreatedAllOf
     */
    data?: DistrictObject;
}
/**
 * 
 * @export
 * @interface DistrictsDeleted
 */
export interface DistrictsDeleted extends Event {
    /**
     * 
     * @type {DistrictObject}
     * @memberof DistrictsDeleted
     */
    data?: DistrictObject;
}
/**
 * 
 * @export
 * @interface DistrictsResponse
 */
export interface DistrictsResponse {
    /**
     * 
     * @type {Array<DistrictResponse>}
     * @memberof DistrictsResponse
     */
    data?: Array<DistrictResponse>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof DistrictsResponse
     */
    links?: Array<Link>;
}
/**
 * 
 * @export
 * @interface DistrictsUpdated
 */
export interface DistrictsUpdated extends Event {
    /**
     * 
     * @type {DistrictObject}
     * @memberof DistrictsUpdated
     */
    data?: DistrictObject;
    /**
     * 
     * @type {object}
     * @memberof DistrictsUpdated
     */
    previous_attributes?: object;
}
/**
 * 
 * @export
 * @interface DistrictsUpdatedAllOf
 */
export interface DistrictsUpdatedAllOf {
    /**
     * 
     * @type {DistrictObject}
     * @memberof DistrictsUpdatedAllOf
     */
    data?: DistrictObject;
    /**
     * 
     * @type {object}
     * @memberof DistrictsUpdatedAllOf
     */
    previous_attributes?: object;
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    created?: string;
}
/**
 * 
 * @export
 * @interface EventResponse
 */
export interface EventResponse {
    /**
     * 
     * @type {Event}
     * @memberof EventResponse
     */
    data?: Event;
}
/**
 * 
 * @export
 * @interface EventsResponse
 */
export interface EventsResponse {
    /**
     * 
     * @type {Array<EventResponse>}
     * @memberof EventsResponse
     */
    data?: Array<EventResponse>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof EventsResponse
     */
    links?: Array<Link>;
}
/**
 * 
 * @export
 * @interface InternalError
 */
export interface InternalError {
    /**
     * 
     * @type {string}
     * @memberof InternalError
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    rel?: LinkRelEnum;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    uri?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum LinkRelEnum {
    Next = 'next',
    Prev = 'prev',
    Self = 'self'
}

/**
 * 
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    address?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    city?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    state?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    zip?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    lat?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    lon?: string | null;
}
/**
 * 
 * @export
 * @interface Name
 */
export interface Name {
    /**
     * 
     * @type {string}
     * @memberof Name
     */
    first?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Name
     */
    middle?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Name
     */
    last?: string | null;
}
/**
 * 
 * @export
 * @interface NotFound
 */
export interface NotFound {
    /**
     * 
     * @type {string}
     * @memberof NotFound
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface Principal
 */
export interface Principal {
    /**
     * 
     * @type {string}
     * @memberof Principal
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Principal
     */
    email?: string | null;
}
/**
 * 
 * @export
 * @interface School
 */
export interface School {
    /**
     * 
     * @type {string}
     * @memberof School
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    district?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    high_grade?: SchoolHighGradeEnum;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    last_modified?: string;
    /**
     * 
     * @type {Location}
     * @memberof School
     */
    location?: Location;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    low_grade?: SchoolLowGradeEnum;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    nces_id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    phone?: string | null;
    /**
     * 
     * @type {Principal}
     * @memberof School
     */
    principal?: Principal;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    school_number?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    sis_id?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    state_id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    mdr_number?: string | null;
    /**
     * 
     * @type {object}
     * @memberof School
     */
    ext?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum SchoolHighGradeEnum {
    InfantToddler = 'InfantToddler',
    Preschool = 'Preschool',
    PreKindergarten = 'PreKindergarten',
    TransitionalKindergarten = 'TransitionalKindergarten',
    Kindergarten = 'Kindergarten',
    _1 = '1',
    _2 = '2',
    _3 = '3',
    _4 = '4',
    _5 = '5',
    _6 = '6',
    _7 = '7',
    _8 = '8',
    _9 = '9',
    _10 = '10',
    _11 = '11',
    _12 = '12',
    _13 = '13',
    PostGraduate = 'PostGraduate',
    Ungraded = 'Ungraded',
    Other = 'Other',
    Empty = ''
}
/**
    * @export
    * @enum {string}
    */
export enum SchoolLowGradeEnum {
    InfantToddler = 'InfantToddler',
    Preschool = 'Preschool',
    PreKindergarten = 'PreKindergarten',
    TransitionalKindergarten = 'TransitionalKindergarten',
    Kindergarten = 'Kindergarten',
    _1 = '1',
    _2 = '2',
    _3 = '3',
    _4 = '4',
    _5 = '5',
    _6 = '6',
    _7 = '7',
    _8 = '8',
    _9 = '9',
    _10 = '10',
    _11 = '11',
    _12 = '12',
    _13 = '13',
    PostGraduate = 'PostGraduate',
    Ungraded = 'Ungraded',
    Other = 'Other',
    Empty = ''
}

/**
 * 
 * @export
 * @interface SchoolAdmin
 */
export interface SchoolAdmin {
    /**
     * 
     * @type {string}
     * @memberof SchoolAdmin
     */
    id?: string;
    /**
     * 
     * @type {Credentials}
     * @memberof SchoolAdmin
     */
    credentials?: Credentials;
    /**
     * 
     * @type {string}
     * @memberof SchoolAdmin
     */
    district?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolAdmin
     */
    email?: string;
    /**
     * 
     * @type {AdminName}
     * @memberof SchoolAdmin
     */
    name?: AdminName;
    /**
     * 
     * @type {Array<string>}
     * @memberof SchoolAdmin
     */
    schools?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SchoolAdmin
     */
    staff_id?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolAdmin
     */
    title?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SchoolAdmin
     */
    department?: string | null;
    /**
     * 
     * @type {object}
     * @memberof SchoolAdmin
     */
    ext?: object;
}
/**
 * 
 * @export
 * @interface SchoolAdminObject
 */
export interface SchoolAdminObject {
    /**
     * 
     * @type {SchoolAdmin}
     * @memberof SchoolAdminObject
     */
    object?: SchoolAdmin;
}
/**
 * 
 * @export
 * @interface SchoolAdminResponse
 */
export interface SchoolAdminResponse {
    /**
     * 
     * @type {SchoolAdmin}
     * @memberof SchoolAdminResponse
     */
    data?: SchoolAdmin;
}
/**
 * 
 * @export
 * @interface SchoolAdminsResponse
 */
export interface SchoolAdminsResponse {
    /**
     * 
     * @type {Array<SchoolAdminResponse>}
     * @memberof SchoolAdminsResponse
     */
    data?: Array<SchoolAdminResponse>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof SchoolAdminsResponse
     */
    links?: Array<Link>;
}
/**
 * 
 * @export
 * @interface SchoolEnrollment
 */
export interface SchoolEnrollment {
    /**
     * 
     * @type {string}
     * @memberof SchoolEnrollment
     */
    school?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolEnrollment
     */
    start_date?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolEnrollment
     */
    end_date?: string;
}
/**
 * 
 * @export
 * @interface SchoolObject
 */
export interface SchoolObject {
    /**
     * 
     * @type {School}
     * @memberof SchoolObject
     */
    object?: School;
}
/**
 * 
 * @export
 * @interface SchoolResponse
 */
export interface SchoolResponse {
    /**
     * 
     * @type {School}
     * @memberof SchoolResponse
     */
    data?: School;
}
/**
 * 
 * @export
 * @interface SchooladminsCreated
 */
export interface SchooladminsCreated extends Event {
    /**
     * 
     * @type {SchoolAdminObject}
     * @memberof SchooladminsCreated
     */
    data?: SchoolAdminObject;
}
/**
 * 
 * @export
 * @interface SchooladminsCreatedAllOf
 */
export interface SchooladminsCreatedAllOf {
    /**
     * 
     * @type {SchoolAdminObject}
     * @memberof SchooladminsCreatedAllOf
     */
    data?: SchoolAdminObject;
}
/**
 * 
 * @export
 * @interface SchooladminsDeleted
 */
export interface SchooladminsDeleted extends Event {
    /**
     * 
     * @type {SchoolAdminObject}
     * @memberof SchooladminsDeleted
     */
    data?: SchoolAdminObject;
}
/**
 * 
 * @export
 * @interface SchooladminsUpdated
 */
export interface SchooladminsUpdated extends Event {
    /**
     * 
     * @type {SchoolAdminObject}
     * @memberof SchooladminsUpdated
     */
    data?: SchoolAdminObject;
    /**
     * 
     * @type {object}
     * @memberof SchooladminsUpdated
     */
    previous_attributes?: object;
}
/**
 * 
 * @export
 * @interface SchooladminsUpdatedAllOf
 */
export interface SchooladminsUpdatedAllOf {
    /**
     * 
     * @type {SchoolAdminObject}
     * @memberof SchooladminsUpdatedAllOf
     */
    data?: SchoolAdminObject;
    /**
     * 
     * @type {object}
     * @memberof SchooladminsUpdatedAllOf
     */
    previous_attributes?: object;
}
/**
 * 
 * @export
 * @interface SchoolsCreated
 */
export interface SchoolsCreated extends Event {
    /**
     * 
     * @type {SchoolObject}
     * @memberof SchoolsCreated
     */
    data?: SchoolObject;
}
/**
 * 
 * @export
 * @interface SchoolsCreatedAllOf
 */
export interface SchoolsCreatedAllOf {
    /**
     * 
     * @type {SchoolObject}
     * @memberof SchoolsCreatedAllOf
     */
    data?: SchoolObject;
}
/**
 * 
 * @export
 * @interface SchoolsDeleted
 */
export interface SchoolsDeleted extends Event {
    /**
     * 
     * @type {SchoolObject}
     * @memberof SchoolsDeleted
     */
    data?: SchoolObject;
}
/**
 * 
 * @export
 * @interface SchoolsResponse
 */
export interface SchoolsResponse {
    /**
     * 
     * @type {Array<SchoolResponse>}
     * @memberof SchoolsResponse
     */
    data?: Array<SchoolResponse>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof SchoolsResponse
     */
    links?: Array<Link>;
}
/**
 * 
 * @export
 * @interface SchoolsUpdated
 */
export interface SchoolsUpdated extends Event {
    /**
     * 
     * @type {SchoolObject}
     * @memberof SchoolsUpdated
     */
    data?: SchoolObject;
    /**
     * 
     * @type {object}
     * @memberof SchoolsUpdated
     */
    previous_attributes?: object;
}
/**
 * 
 * @export
 * @interface SchoolsUpdatedAllOf
 */
export interface SchoolsUpdatedAllOf {
    /**
     * 
     * @type {SchoolObject}
     * @memberof SchoolsUpdatedAllOf
     */
    data?: SchoolObject;
    /**
     * 
     * @type {object}
     * @memberof SchoolsUpdatedAllOf
     */
    previous_attributes?: object;
}
/**
 * 
 * @export
 * @interface Section
 */
export interface Section {
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    course?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    district?: string;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    grade?: SectionGradeEnum;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    last_modified?: string;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    period?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    school?: string;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    section_number?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    sis_id?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Section
     */
    students?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    subject?: SectionSubjectEnum;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    teacher?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Section
     */
    teachers?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    term_id?: string | null;
    /**
     * 
     * @type {object}
     * @memberof Section
     */
    ext?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum SectionGradeEnum {
    InfantToddler = 'InfantToddler',
    Preschool = 'Preschool',
    PreKindergarten = 'PreKindergarten',
    TransitionalKindergarten = 'TransitionalKindergarten',
    Kindergarten = 'Kindergarten',
    _1 = '1',
    _2 = '2',
    _3 = '3',
    _4 = '4',
    _5 = '5',
    _6 = '6',
    _7 = '7',
    _8 = '8',
    _9 = '9',
    _10 = '10',
    _11 = '11',
    _12 = '12',
    _13 = '13',
    PostGraduate = 'PostGraduate',
    Ungraded = 'Ungraded',
    Other = 'Other',
    Empty = ''
}
/**
    * @export
    * @enum {string}
    */
export enum SectionSubjectEnum {
    EnglishLanguageArts = 'english/language arts',
    Math = 'math',
    Science = 'science',
    SocialStudies = 'social studies',
    Language = 'language',
    HomeroomAdvisory = 'homeroom/advisory',
    InterventionsOnlineLearning = 'interventions/online learning',
    TechnologyAndEngineering = 'technology and engineering',
    PEAndHealth = 'PE and health',
    ArtsAndMusic = 'arts and music',
    Other = 'other',
    Empty = ''
}

/**
 * 
 * @export
 * @interface SectionObject
 */
export interface SectionObject {
    /**
     * 
     * @type {Section}
     * @memberof SectionObject
     */
    object?: Section;
}
/**
 * 
 * @export
 * @interface SectionResponse
 */
export interface SectionResponse {
    /**
     * 
     * @type {Section}
     * @memberof SectionResponse
     */
    data?: Section;
}
/**
 * 
 * @export
 * @interface SectionsCreated
 */
export interface SectionsCreated extends Event {
    /**
     * 
     * @type {SectionObject}
     * @memberof SectionsCreated
     */
    data?: SectionObject;
}
/**
 * 
 * @export
 * @interface SectionsCreatedAllOf
 */
export interface SectionsCreatedAllOf {
    /**
     * 
     * @type {SectionObject}
     * @memberof SectionsCreatedAllOf
     */
    data?: SectionObject;
}
/**
 * 
 * @export
 * @interface SectionsDeleted
 */
export interface SectionsDeleted extends Event {
    /**
     * 
     * @type {SectionObject}
     * @memberof SectionsDeleted
     */
    data?: SectionObject;
}
/**
 * 
 * @export
 * @interface SectionsResponse
 */
export interface SectionsResponse {
    /**
     * 
     * @type {Array<SectionResponse>}
     * @memberof SectionsResponse
     */
    data?: Array<SectionResponse>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof SectionsResponse
     */
    links?: Array<Link>;
}
/**
 * 
 * @export
 * @interface SectionsUpdated
 */
export interface SectionsUpdated extends Event {
    /**
     * 
     * @type {SectionObject}
     * @memberof SectionsUpdated
     */
    data?: SectionObject;
    /**
     * 
     * @type {object}
     * @memberof SectionsUpdated
     */
    previous_attributes?: object;
}
/**
 * 
 * @export
 * @interface SectionsUpdatedAllOf
 */
export interface SectionsUpdatedAllOf {
    /**
     * 
     * @type {SectionObject}
     * @memberof SectionsUpdatedAllOf
     */
    data?: SectionObject;
    /**
     * 
     * @type {object}
     * @memberof SectionsUpdatedAllOf
     */
    previous_attributes?: object;
}
/**
 * 
 * @export
 * @interface Student
 */
export interface Student {
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    created?: string;
    /**
     * 
     * @type {Credentials}
     * @memberof Student
     */
    credentials?: Credentials;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    district?: string;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    dob?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    ell_status?: StudentEllStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    email?: string | null;
    /**
     * 
     * @type {Array<SchoolEnrollment>}
     * @memberof Student
     */
    enrollments?: Array<SchoolEnrollment>;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    gender?: StudentGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    graduation_year?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    grade?: StudentGradeEnum;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    hispanic_ethnicity?: StudentHispanicEthnicityEnum;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    home_language?: StudentHomeLanguageEnum;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    iep_status?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    last_modified?: string;
    /**
     * 
     * @type {Location}
     * @memberof Student
     */
    location?: Location;
    /**
     * 
     * @type {Name}
     * @memberof Student
     */
    name?: Name;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    race?: StudentRaceEnum;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    school?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Student
     */
    schools?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    sis_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    state_id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    student_number?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    unweighted_gpa?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    weighted_gpa?: string | null;
    /**
     * 
     * @type {object}
     * @memberof Student
     */
    ext?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum StudentEllStatusEnum {
    Y = 'Y',
    N = 'N',
    Empty = ''
}
/**
    * @export
    * @enum {string}
    */
export enum StudentGenderEnum {
    M = 'M',
    F = 'F',
    X = 'X',
    Empty = ''
}
/**
    * @export
    * @enum {string}
    */
export enum StudentGradeEnum {
    InfantToddler = 'InfantToddler',
    Preschool = 'Preschool',
    PreKindergarten = 'PreKindergarten',
    TransitionalKindergarten = 'TransitionalKindergarten',
    Kindergarten = 'Kindergarten',
    _1 = '1',
    _2 = '2',
    _3 = '3',
    _4 = '4',
    _5 = '5',
    _6 = '6',
    _7 = '7',
    _8 = '8',
    _9 = '9',
    _10 = '10',
    _11 = '11',
    _12 = '12',
    _13 = '13',
    PostGraduate = 'PostGraduate',
    Ungraded = 'Ungraded',
    Other = 'Other',
    Empty = ''
}
/**
    * @export
    * @enum {string}
    */
export enum StudentHispanicEthnicityEnum {
    Y = 'Y',
    N = 'N',
    Empty = ''
}
/**
    * @export
    * @enum {string}
    */
export enum StudentHomeLanguageEnum {
    English = 'English',
    Albanian = 'Albanian',
    Amharic = 'Amharic',
    Arabic = 'Arabic',
    Bengali = 'Bengali',
    Bosnian = 'Bosnian',
    Burmese = 'Burmese',
    Cantonese = 'Cantonese',
    Chinese = 'Chinese',
    Dutch = 'Dutch',
    Farsi = 'Farsi',
    French = 'French',
    German = 'German',
    Hebrew = 'Hebrew',
    Hindi = 'Hindi',
    Hmong = 'Hmong',
    Ilocano = 'Ilocano',
    Japanese = 'Japanese',
    Javanese = 'Javanese',
    Karen = 'Karen',
    Khmer = 'Khmer',
    Korean = 'Korean',
    Laotian = 'Laotian',
    Latvian = 'Latvian',
    Malay = 'Malay',
    Mandarin = 'Mandarin',
    Nepali = 'Nepali',
    Oromo = 'Oromo',
    Polish = 'Polish',
    Portuguese = 'Portuguese',
    Punjabi = 'Punjabi',
    Romanian = 'Romanian',
    Russian = 'Russian',
    Samoan = 'Samoan',
    Serbian = 'Serbian',
    Somali = 'Somali',
    Spanish = 'Spanish',
    Swahili = 'Swahili',
    Tagalog = 'Tagalog',
    Tamil = 'Tamil',
    Telugu = 'Telugu',
    Thai = 'Thai',
    Tigrinya = 'Tigrinya',
    Turkish = 'Turkish',
    Ukrainian = 'Ukrainian',
    Urdu = 'Urdu',
    Vietnamese = 'Vietnamese',
    Empty = ''
}
/**
    * @export
    * @enum {string}
    */
export enum StudentRaceEnum {
    Caucasian = 'Caucasian',
    Asian = 'Asian',
    BlackOrAfricanAmerican = 'Black or African American',
    AmericanIndian = 'American Indian',
    HawaiianOrOtherPacificIslander = 'Hawaiian or Other Pacific Islander',
    TwoOrMoreRaces = 'Two or More Races',
    Unknown = 'Unknown',
    Empty = ''
}

/**
 * 
 * @export
 * @interface StudentObject
 */
export interface StudentObject {
    /**
     * 
     * @type {Student}
     * @memberof StudentObject
     */
    object?: Student;
}
/**
 * 
 * @export
 * @interface StudentResponse
 */
export interface StudentResponse {
    /**
     * 
     * @type {Student}
     * @memberof StudentResponse
     */
    data?: Student;
}
/**
 * 
 * @export
 * @interface StudentsCreated
 */
export interface StudentsCreated extends Event {
    /**
     * 
     * @type {StudentObject}
     * @memberof StudentsCreated
     */
    data?: StudentObject;
}
/**
 * 
 * @export
 * @interface StudentsCreatedAllOf
 */
export interface StudentsCreatedAllOf {
    /**
     * 
     * @type {StudentObject}
     * @memberof StudentsCreatedAllOf
     */
    data?: StudentObject;
}
/**
 * 
 * @export
 * @interface StudentsDeleted
 */
export interface StudentsDeleted extends Event {
    /**
     * 
     * @type {StudentObject}
     * @memberof StudentsDeleted
     */
    data?: StudentObject;
}
/**
 * 
 * @export
 * @interface StudentsResponse
 */
export interface StudentsResponse {
    /**
     * 
     * @type {Array<StudentResponse>}
     * @memberof StudentsResponse
     */
    data?: Array<StudentResponse>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof StudentsResponse
     */
    links?: Array<Link>;
}
/**
 * 
 * @export
 * @interface StudentsUpdated
 */
export interface StudentsUpdated extends Event {
    /**
     * 
     * @type {StudentObject}
     * @memberof StudentsUpdated
     */
    data?: StudentObject;
    /**
     * 
     * @type {object}
     * @memberof StudentsUpdated
     */
    previous_attributes?: object;
}
/**
 * 
 * @export
 * @interface StudentsUpdatedAllOf
 */
export interface StudentsUpdatedAllOf {
    /**
     * 
     * @type {StudentObject}
     * @memberof StudentsUpdatedAllOf
     */
    data?: StudentObject;
    /**
     * 
     * @type {object}
     * @memberof StudentsUpdatedAllOf
     */
    previous_attributes?: object;
}
/**
 * 
 * @export
 * @interface Teacher
 */
export interface Teacher {
    /**
     * 
     * @type {string}
     * @memberof Teacher
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Teacher
     */
    created?: string;
    /**
     * 
     * @type {Credentials}
     * @memberof Teacher
     */
    credentials?: Credentials;
    /**
     * 
     * @type {string}
     * @memberof Teacher
     */
    district?: string;
    /**
     * 
     * @type {string}
     * @memberof Teacher
     */
    email?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Teacher
     */
    last_modified?: string;
    /**
     * 
     * @type {Name}
     * @memberof Teacher
     */
    name?: Name;
    /**
     * 
     * @type {string}
     * @memberof Teacher
     */
    school?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Teacher
     */
    schools?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Teacher
     */
    sis_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Teacher
     */
    state_id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Teacher
     */
    teacher_number?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Teacher
     */
    title?: string | null;
    /**
     * 
     * @type {object}
     * @memberof Teacher
     */
    ext?: object;
}
/**
 * 
 * @export
 * @interface TeacherObject
 */
export interface TeacherObject {
    /**
     * 
     * @type {Teacher}
     * @memberof TeacherObject
     */
    object?: Teacher;
}
/**
 * 
 * @export
 * @interface TeacherResponse
 */
export interface TeacherResponse {
    /**
     * 
     * @type {Teacher}
     * @memberof TeacherResponse
     */
    data?: Teacher;
}
/**
 * 
 * @export
 * @interface TeachersCreated
 */
export interface TeachersCreated extends Event {
    /**
     * 
     * @type {TeacherObject}
     * @memberof TeachersCreated
     */
    data?: TeacherObject;
}
/**
 * 
 * @export
 * @interface TeachersCreatedAllOf
 */
export interface TeachersCreatedAllOf {
    /**
     * 
     * @type {TeacherObject}
     * @memberof TeachersCreatedAllOf
     */
    data?: TeacherObject;
}
/**
 * 
 * @export
 * @interface TeachersDeleted
 */
export interface TeachersDeleted extends Event {
    /**
     * 
     * @type {TeacherObject}
     * @memberof TeachersDeleted
     */
    data?: TeacherObject;
}
/**
 * 
 * @export
 * @interface TeachersResponse
 */
export interface TeachersResponse {
    /**
     * 
     * @type {Array<TeacherResponse>}
     * @memberof TeachersResponse
     */
    data?: Array<TeacherResponse>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof TeachersResponse
     */
    links?: Array<Link>;
}
/**
 * 
 * @export
 * @interface TeachersUpdated
 */
export interface TeachersUpdated extends Event {
    /**
     * 
     * @type {TeacherObject}
     * @memberof TeachersUpdated
     */
    data?: TeacherObject;
    /**
     * 
     * @type {object}
     * @memberof TeachersUpdated
     */
    previous_attributes?: object;
}
/**
 * 
 * @export
 * @interface TeachersUpdatedAllOf
 */
export interface TeachersUpdatedAllOf {
    /**
     * 
     * @type {TeacherObject}
     * @memberof TeachersUpdatedAllOf
     */
    data?: TeacherObject;
    /**
     * 
     * @type {object}
     * @memberof TeachersUpdatedAllOf
     */
    previous_attributes?: object;
}
/**
 * 
 * @export
 * @interface Term
 */
export interface Term {
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    start_date?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    end_date?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    district?: string;
}
/**
 * 
 * @export
 * @interface TermObject
 */
export interface TermObject {
    /**
     * 
     * @type {Term}
     * @memberof TermObject
     */
    object?: Term;
}
/**
 * 
 * @export
 * @interface TermResponse
 */
export interface TermResponse {
    /**
     * 
     * @type {Term}
     * @memberof TermResponse
     */
    data?: Term;
}
/**
 * 
 * @export
 * @interface TermsCreated
 */
export interface TermsCreated extends Event {
    /**
     * 
     * @type {TermObject}
     * @memberof TermsCreated
     */
    data?: TermObject;
}
/**
 * 
 * @export
 * @interface TermsCreatedAllOf
 */
export interface TermsCreatedAllOf {
    /**
     * 
     * @type {TermObject}
     * @memberof TermsCreatedAllOf
     */
    data?: TermObject;
}
/**
 * 
 * @export
 * @interface TermsDeleted
 */
export interface TermsDeleted extends Event {
    /**
     * 
     * @type {TermObject}
     * @memberof TermsDeleted
     */
    data?: TermObject;
}
/**
 * 
 * @export
 * @interface TermsResponse
 */
export interface TermsResponse {
    /**
     * 
     * @type {Array<TermResponse>}
     * @memberof TermsResponse
     */
    data?: Array<TermResponse>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof TermsResponse
     */
    links?: Array<Link>;
}
/**
 * 
 * @export
 * @interface TermsUpdated
 */
export interface TermsUpdated extends Event {
    /**
     * 
     * @type {TermObject}
     * @memberof TermsUpdated
     */
    data?: TermObject;
    /**
     * 
     * @type {object}
     * @memberof TermsUpdated
     */
    previous_attributes?: object;
}
/**
 * 
 * @export
 * @interface TermsUpdatedAllOf
 */
export interface TermsUpdatedAllOf {
    /**
     * 
     * @type {TermObject}
     * @memberof TermsUpdatedAllOf
     */
    data?: TermObject;
    /**
     * 
     * @type {object}
     * @memberof TermsUpdatedAllOf
     */
    previous_attributes?: object;
}

/**
 * ContactsApi - axios parameter creator
 * @export
 */
export const ContactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a specific student contact
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContact: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getContact.');
            }
            const localVarPath = `/contacts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of student contacts
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContacts: async (limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/contacts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the district for a student contact
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForContact: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDistrictForContact.');
            }
            const localVarPath = `/contacts/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the students for a student contact
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForContact: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getStudentsForContact.');
            }
            const localVarPath = `/contacts/{id}/students`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactsApi - functional programming interface
 * @export
 */
export const ContactsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a specific student contact
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContact(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactResponse>> {
            const localVarAxiosArgs = await ContactsApiAxiosParamCreator(configuration).getContact(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of student contacts
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContacts(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactsResponse>> {
            const localVarAxiosArgs = await ContactsApiAxiosParamCreator(configuration).getContacts(limit, startingAfter, endingBefore, count, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the district for a student contact
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForContact(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrictResponse>> {
            const localVarAxiosArgs = await ContactsApiAxiosParamCreator(configuration).getDistrictForContact(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the students for a student contact
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudentsForContact(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentsResponse>> {
            const localVarAxiosArgs = await ContactsApiAxiosParamCreator(configuration).getStudentsForContact(id, limit, startingAfter, endingBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ContactsApi - factory interface
 * @export
 */
export const ContactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns a specific student contact
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContact(id: string, options?: any): AxiosPromise<ContactResponse> {
            return ContactsApiFp(configuration).getContact(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of student contacts
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContacts(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options?: any): AxiosPromise<ContactsResponse> {
            return ContactsApiFp(configuration).getContacts(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the district for a student contact
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForContact(id: string, options?: any): AxiosPromise<DistrictResponse> {
            return ContactsApiFp(configuration).getDistrictForContact(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the students for a student contact
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForContact(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<StudentsResponse> {
            return ContactsApiFp(configuration).getStudentsForContact(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactsApi - object-oriented interface
 * @export
 * @class ContactsApi
 * @extends {BaseAPI}
 */
export class ContactsApi extends BaseAPI {
    /**
     * Returns a specific student contact
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public getContact(id: string, options?: any) {
        return ContactsApiFp(this.configuration).getContact(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of student contacts
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {'' | 'true'} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public getContacts(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options?: any) {
        return ContactsApiFp(this.configuration).getContacts(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the district for a student contact
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public getDistrictForContact(id: string, options?: any) {
        return ContactsApiFp(this.configuration).getDistrictForContact(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the students for a student contact
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public getStudentsForContact(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any) {
        return ContactsApiFp(this.configuration).getStudentsForContact(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * CoursesApi - axios parameter creator
 * @export
 */
export const CoursesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a specific course
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourse: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCourse.');
            }
            const localVarPath = `/courses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of courses
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourses: async (limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/courses`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the district for a course
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForCourse: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDistrictForCourse.');
            }
            const localVarPath = `/courses/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the sections for a Courses
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForCourse: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSectionsForCourse.');
            }
            const localVarPath = `/courses/{id}/sections`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoursesApi - functional programming interface
 * @export
 */
export const CoursesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a specific course
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourse(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseResponse>> {
            const localVarAxiosArgs = await CoursesApiAxiosParamCreator(configuration).getCourse(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of courses
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourses(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoursesResponse>> {
            const localVarAxiosArgs = await CoursesApiAxiosParamCreator(configuration).getCourses(limit, startingAfter, endingBefore, count, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the district for a course
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForCourse(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrictResponse>> {
            const localVarAxiosArgs = await CoursesApiAxiosParamCreator(configuration).getDistrictForCourse(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the sections for a Courses
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSectionsForCourse(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionsResponse>> {
            const localVarAxiosArgs = await CoursesApiAxiosParamCreator(configuration).getSectionsForCourse(id, limit, startingAfter, endingBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CoursesApi - factory interface
 * @export
 */
export const CoursesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns a specific course
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourse(id: string, options?: any): AxiosPromise<CourseResponse> {
            return CoursesApiFp(configuration).getCourse(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of courses
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourses(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options?: any): AxiosPromise<CoursesResponse> {
            return CoursesApiFp(configuration).getCourses(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the district for a course
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForCourse(id: string, options?: any): AxiosPromise<DistrictResponse> {
            return CoursesApiFp(configuration).getDistrictForCourse(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the sections for a Courses
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForCourse(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<SectionsResponse> {
            return CoursesApiFp(configuration).getSectionsForCourse(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoursesApi - object-oriented interface
 * @export
 * @class CoursesApi
 * @extends {BaseAPI}
 */
export class CoursesApi extends BaseAPI {
    /**
     * Returns a specific course
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public getCourse(id: string, options?: any) {
        return CoursesApiFp(this.configuration).getCourse(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of courses
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {'' | 'true'} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public getCourses(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options?: any) {
        return CoursesApiFp(this.configuration).getCourses(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the district for a course
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public getDistrictForCourse(id: string, options?: any) {
        return CoursesApiFp(this.configuration).getDistrictForCourse(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the sections for a Courses
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public getSectionsForCourse(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any) {
        return CoursesApiFp(this.configuration).getSectionsForCourse(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * DistrictAdminsApi - axios parameter creator
 * @export
 */
export const DistrictAdminsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a specific district admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictAdmin: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDistrictAdmin.');
            }
            const localVarPath = `/district_admins/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of district admins
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictAdmins: async (limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/district_admins`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the district for a district admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForDistrictAdmin: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDistrictForDistrictAdmin.');
            }
            const localVarPath = `/district_admins/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DistrictAdminsApi - functional programming interface
 * @export
 */
export const DistrictAdminsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a specific district admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictAdmin(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrictAdminResponse>> {
            const localVarAxiosArgs = await DistrictAdminsApiAxiosParamCreator(configuration).getDistrictAdmin(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of district admins
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictAdmins(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrictAdminsResponse>> {
            const localVarAxiosArgs = await DistrictAdminsApiAxiosParamCreator(configuration).getDistrictAdmins(limit, startingAfter, endingBefore, count, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the district for a district admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForDistrictAdmin(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrictResponse>> {
            const localVarAxiosArgs = await DistrictAdminsApiAxiosParamCreator(configuration).getDistrictForDistrictAdmin(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DistrictAdminsApi - factory interface
 * @export
 */
export const DistrictAdminsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns a specific district admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictAdmin(id: string, options?: any): AxiosPromise<DistrictAdminResponse> {
            return DistrictAdminsApiFp(configuration).getDistrictAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of district admins
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictAdmins(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options?: any): AxiosPromise<DistrictAdminsResponse> {
            return DistrictAdminsApiFp(configuration).getDistrictAdmins(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the district for a district admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForDistrictAdmin(id: string, options?: any): AxiosPromise<DistrictResponse> {
            return DistrictAdminsApiFp(configuration).getDistrictForDistrictAdmin(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DistrictAdminsApi - object-oriented interface
 * @export
 * @class DistrictAdminsApi
 * @extends {BaseAPI}
 */
export class DistrictAdminsApi extends BaseAPI {
    /**
     * Returns a specific district admin
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictAdminsApi
     */
    public getDistrictAdmin(id: string, options?: any) {
        return DistrictAdminsApiFp(this.configuration).getDistrictAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of district admins
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {'' | 'true'} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictAdminsApi
     */
    public getDistrictAdmins(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options?: any) {
        return DistrictAdminsApiFp(this.configuration).getDistrictAdmins(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the district for a district admin
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictAdminsApi
     */
    public getDistrictForDistrictAdmin(id: string, options?: any) {
        return DistrictAdminsApiFp(this.configuration).getDistrictForDistrictAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * DistrictsApi - axios parameter creator
 * @export
 */
export const DistrictsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a specific district
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrict: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDistrict.');
            }
            const localVarPath = `/districts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of districts
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistricts: async (count?: '' | 'true', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/districts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DistrictsApi - functional programming interface
 * @export
 */
export const DistrictsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a specific district
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrict(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrictResponse>> {
            const localVarAxiosArgs = await DistrictsApiAxiosParamCreator(configuration).getDistrict(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of districts
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistricts(count?: '' | 'true', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrictsResponse>> {
            const localVarAxiosArgs = await DistrictsApiAxiosParamCreator(configuration).getDistricts(count, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DistrictsApi - factory interface
 * @export
 */
export const DistrictsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns a specific district
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrict(id: string, options?: any): AxiosPromise<DistrictResponse> {
            return DistrictsApiFp(configuration).getDistrict(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of districts
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistricts(count?: '' | 'true', options?: any): AxiosPromise<DistrictsResponse> {
            return DistrictsApiFp(configuration).getDistricts(count, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DistrictsApi - object-oriented interface
 * @export
 * @class DistrictsApi
 * @extends {BaseAPI}
 */
export class DistrictsApi extends BaseAPI {
    /**
     * Returns a specific district
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictsApi
     */
    public getDistrict(id: string, options?: any) {
        return DistrictsApiFp(this.configuration).getDistrict(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of districts
     * @param {'' | 'true'} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictsApi
     */
    public getDistricts(count?: '' | 'true', options?: any) {
        return DistrictsApiFp(this.configuration).getDistricts(count, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the specific event
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getEvent.');
            }
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of events
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {string} [school] 
         * @param {Array<string>} [recordType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (limit?: number, startingAfter?: string, endingBefore?: string, school?: string, recordType?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/events`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (school !== undefined) {
                localVarQueryParameter['school'] = school;
            }

            if (recordType) {
                localVarQueryParameter['record_type'] = recordType;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the specific event
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvent(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventResponse>> {
            const localVarAxiosArgs = await EventsApiAxiosParamCreator(configuration).getEvent(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of events
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {string} [school] 
         * @param {Array<string>} [recordType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(limit?: number, startingAfter?: string, endingBefore?: string, school?: string, recordType?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventsResponse>> {
            const localVarAxiosArgs = await EventsApiAxiosParamCreator(configuration).getEvents(limit, startingAfter, endingBefore, school, recordType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns the specific event
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(id: string, options?: any): AxiosPromise<EventResponse> {
            return EventsApiFp(configuration).getEvent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of events
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {string} [school] 
         * @param {Array<string>} [recordType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(limit?: number, startingAfter?: string, endingBefore?: string, school?: string, recordType?: Array<string>, options?: any): AxiosPromise<EventsResponse> {
            return EventsApiFp(configuration).getEvents(limit, startingAfter, endingBefore, school, recordType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * Returns the specific event
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEvent(id: string, options?: any) {
        return EventsApiFp(this.configuration).getEvent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of events
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {string} [school] 
     * @param {Array<string>} [recordType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEvents(limit?: number, startingAfter?: string, endingBefore?: string, school?: string, recordType?: Array<string>, options?: any) {
        return EventsApiFp(this.configuration).getEvents(limit, startingAfter, endingBefore, school, recordType, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SchoolAdminsApi - axios parameter creator
 * @export
 */
export const SchoolAdminsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the district for a school admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForSchoolAdmin: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDistrictForSchoolAdmin.');
            }
            const localVarPath = `/school_admins/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific school admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolAdmin: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSchoolAdmin.');
            }
            const localVarPath = `/school_admins/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of school admins
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolAdmins: async (limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/school_admins`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the schools for a school admin
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolsForSchoolAdmin: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSchoolsForSchoolAdmin.');
            }
            const localVarPath = `/school_admins/{id}/schools`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchoolAdminsApi - functional programming interface
 * @export
 */
export const SchoolAdminsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the district for a school admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForSchoolAdmin(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrictResponse>> {
            const localVarAxiosArgs = await SchoolAdminsApiAxiosParamCreator(configuration).getDistrictForSchoolAdmin(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a specific school admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolAdmin(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolAdminResponse>> {
            const localVarAxiosArgs = await SchoolAdminsApiAxiosParamCreator(configuration).getSchoolAdmin(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of school admins
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolAdmins(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolAdminsResponse>> {
            const localVarAxiosArgs = await SchoolAdminsApiAxiosParamCreator(configuration).getSchoolAdmins(limit, startingAfter, endingBefore, count, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the schools for a school admin
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolsForSchoolAdmin(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolsResponse>> {
            const localVarAxiosArgs = await SchoolAdminsApiAxiosParamCreator(configuration).getSchoolsForSchoolAdmin(id, limit, startingAfter, endingBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SchoolAdminsApi - factory interface
 * @export
 */
export const SchoolAdminsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns the district for a school admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForSchoolAdmin(id: string, options?: any): AxiosPromise<DistrictResponse> {
            return SchoolAdminsApiFp(configuration).getDistrictForSchoolAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific school admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolAdmin(id: string, options?: any): AxiosPromise<SchoolAdminResponse> {
            return SchoolAdminsApiFp(configuration).getSchoolAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of school admins
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolAdmins(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options?: any): AxiosPromise<SchoolAdminsResponse> {
            return SchoolAdminsApiFp(configuration).getSchoolAdmins(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the schools for a school admin
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolsForSchoolAdmin(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<SchoolsResponse> {
            return SchoolAdminsApiFp(configuration).getSchoolsForSchoolAdmin(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchoolAdminsApi - object-oriented interface
 * @export
 * @class SchoolAdminsApi
 * @extends {BaseAPI}
 */
export class SchoolAdminsApi extends BaseAPI {
    /**
     * Returns the district for a school admin
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolAdminsApi
     */
    public getDistrictForSchoolAdmin(id: string, options?: any) {
        return SchoolAdminsApiFp(this.configuration).getDistrictForSchoolAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific school admin
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolAdminsApi
     */
    public getSchoolAdmin(id: string, options?: any) {
        return SchoolAdminsApiFp(this.configuration).getSchoolAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of school admins
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {'' | 'true'} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolAdminsApi
     */
    public getSchoolAdmins(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options?: any) {
        return SchoolAdminsApiFp(this.configuration).getSchoolAdmins(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the schools for a school admin
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolAdminsApi
     */
    public getSchoolsForSchoolAdmin(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any) {
        return SchoolAdminsApiFp(this.configuration).getSchoolsForSchoolAdmin(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SchoolsApi - axios parameter creator
 * @export
 */
export const SchoolsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the district for a school
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForSchool: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDistrictForSchool.');
            }
            const localVarPath = `/schools/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific school
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchool: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSchool.');
            }
            const localVarPath = `/schools/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of schools
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchools: async (limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/schools`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the sections for a school
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForSchool: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSectionsForSchool.');
            }
            const localVarPath = `/schools/{id}/sections`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the students for a school
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForSchool: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getStudentsForSchool.');
            }
            const localVarPath = `/schools/{id}/students`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the teachers for a school
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachersForSchool: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTeachersForSchool.');
            }
            const localVarPath = `/schools/{id}/teachers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchoolsApi - functional programming interface
 * @export
 */
export const SchoolsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the district for a school
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForSchool(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrictResponse>> {
            const localVarAxiosArgs = await SchoolsApiAxiosParamCreator(configuration).getDistrictForSchool(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a specific school
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchool(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolResponse>> {
            const localVarAxiosArgs = await SchoolsApiAxiosParamCreator(configuration).getSchool(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of schools
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchools(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolsResponse>> {
            const localVarAxiosArgs = await SchoolsApiAxiosParamCreator(configuration).getSchools(limit, startingAfter, endingBefore, count, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the sections for a school
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSectionsForSchool(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionsResponse>> {
            const localVarAxiosArgs = await SchoolsApiAxiosParamCreator(configuration).getSectionsForSchool(id, limit, startingAfter, endingBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the students for a school
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudentsForSchool(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentsResponse>> {
            const localVarAxiosArgs = await SchoolsApiAxiosParamCreator(configuration).getStudentsForSchool(id, limit, startingAfter, endingBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the teachers for a school
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeachersForSchool(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeachersResponse>> {
            const localVarAxiosArgs = await SchoolsApiAxiosParamCreator(configuration).getTeachersForSchool(id, limit, startingAfter, endingBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SchoolsApi - factory interface
 * @export
 */
export const SchoolsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns the district for a school
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForSchool(id: string, options?: any): AxiosPromise<DistrictResponse> {
            return SchoolsApiFp(configuration).getDistrictForSchool(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific school
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchool(id: string, options?: any): AxiosPromise<SchoolResponse> {
            return SchoolsApiFp(configuration).getSchool(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of schools
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchools(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options?: any): AxiosPromise<SchoolsResponse> {
            return SchoolsApiFp(configuration).getSchools(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the sections for a school
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForSchool(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<SectionsResponse> {
            return SchoolsApiFp(configuration).getSectionsForSchool(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the students for a school
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForSchool(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<StudentsResponse> {
            return SchoolsApiFp(configuration).getStudentsForSchool(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the teachers for a school
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachersForSchool(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<TeachersResponse> {
            return SchoolsApiFp(configuration).getTeachersForSchool(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchoolsApi - object-oriented interface
 * @export
 * @class SchoolsApi
 * @extends {BaseAPI}
 */
export class SchoolsApi extends BaseAPI {
    /**
     * Returns the district for a school
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolsApi
     */
    public getDistrictForSchool(id: string, options?: any) {
        return SchoolsApiFp(this.configuration).getDistrictForSchool(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific school
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolsApi
     */
    public getSchool(id: string, options?: any) {
        return SchoolsApiFp(this.configuration).getSchool(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of schools
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {'' | 'true'} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolsApi
     */
    public getSchools(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options?: any) {
        return SchoolsApiFp(this.configuration).getSchools(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the sections for a school
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolsApi
     */
    public getSectionsForSchool(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any) {
        return SchoolsApiFp(this.configuration).getSectionsForSchool(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the students for a school
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolsApi
     */
    public getStudentsForSchool(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any) {
        return SchoolsApiFp(this.configuration).getStudentsForSchool(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the teachers for a school
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolsApi
     */
    public getTeachersForSchool(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any) {
        return SchoolsApiFp(this.configuration).getTeachersForSchool(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SectionsApi - axios parameter creator
 * @export
 */
export const SectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the course for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseForSection: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCourseForSection.');
            }
            const localVarPath = `/sections/{id}/course`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the district for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForSection: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDistrictForSection.');
            }
            const localVarPath = `/sections/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the school for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolForSection: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSchoolForSection.');
            }
            const localVarPath = `/sections/{id}/school`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSection: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSection.');
            }
            const localVarPath = `/sections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of sections
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSections: async (limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/sections`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the students for a section
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForSection: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getStudentsForSection.');
            }
            const localVarPath = `/sections/{id}/students`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the primary teacher for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeacherForSection: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTeacherForSection.');
            }
            const localVarPath = `/sections/{id}/teacher`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the teachers for a section
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachersForSection: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTeachersForSection.');
            }
            const localVarPath = `/sections/{id}/teachers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the term for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTermForSection: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTermForSection.');
            }
            const localVarPath = `/sections/{id}/term`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SectionsApi - functional programming interface
 * @export
 */
export const SectionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the course for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseForSection(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseResponse>> {
            const localVarAxiosArgs = await SectionsApiAxiosParamCreator(configuration).getCourseForSection(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the district for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForSection(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrictResponse>> {
            const localVarAxiosArgs = await SectionsApiAxiosParamCreator(configuration).getDistrictForSection(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the school for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolForSection(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolResponse>> {
            const localVarAxiosArgs = await SectionsApiAxiosParamCreator(configuration).getSchoolForSection(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a specific section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSection(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionResponse>> {
            const localVarAxiosArgs = await SectionsApiAxiosParamCreator(configuration).getSection(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of sections
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSections(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionsResponse>> {
            const localVarAxiosArgs = await SectionsApiAxiosParamCreator(configuration).getSections(limit, startingAfter, endingBefore, count, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the students for a section
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudentsForSection(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentsResponse>> {
            const localVarAxiosArgs = await SectionsApiAxiosParamCreator(configuration).getStudentsForSection(id, limit, startingAfter, endingBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the primary teacher for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeacherForSection(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeacherResponse>> {
            const localVarAxiosArgs = await SectionsApiAxiosParamCreator(configuration).getTeacherForSection(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the teachers for a section
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeachersForSection(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeachersResponse>> {
            const localVarAxiosArgs = await SectionsApiAxiosParamCreator(configuration).getTeachersForSection(id, limit, startingAfter, endingBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the term for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTermForSection(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TermResponse>> {
            const localVarAxiosArgs = await SectionsApiAxiosParamCreator(configuration).getTermForSection(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SectionsApi - factory interface
 * @export
 */
export const SectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns the course for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseForSection(id: string, options?: any): AxiosPromise<CourseResponse> {
            return SectionsApiFp(configuration).getCourseForSection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the district for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForSection(id: string, options?: any): AxiosPromise<DistrictResponse> {
            return SectionsApiFp(configuration).getDistrictForSection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the school for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolForSection(id: string, options?: any): AxiosPromise<SchoolResponse> {
            return SectionsApiFp(configuration).getSchoolForSection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSection(id: string, options?: any): AxiosPromise<SectionResponse> {
            return SectionsApiFp(configuration).getSection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of sections
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSections(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options?: any): AxiosPromise<SectionsResponse> {
            return SectionsApiFp(configuration).getSections(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the students for a section
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForSection(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<StudentsResponse> {
            return SectionsApiFp(configuration).getStudentsForSection(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the primary teacher for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeacherForSection(id: string, options?: any): AxiosPromise<TeacherResponse> {
            return SectionsApiFp(configuration).getTeacherForSection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the teachers for a section
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachersForSection(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<TeachersResponse> {
            return SectionsApiFp(configuration).getTeachersForSection(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the term for a section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTermForSection(id: string, options?: any): AxiosPromise<TermResponse> {
            return SectionsApiFp(configuration).getTermForSection(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SectionsApi - object-oriented interface
 * @export
 * @class SectionsApi
 * @extends {BaseAPI}
 */
export class SectionsApi extends BaseAPI {
    /**
     * Returns the course for a section
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    public getCourseForSection(id: string, options?: any) {
        return SectionsApiFp(this.configuration).getCourseForSection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the district for a section
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    public getDistrictForSection(id: string, options?: any) {
        return SectionsApiFp(this.configuration).getDistrictForSection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the school for a section
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    public getSchoolForSection(id: string, options?: any) {
        return SectionsApiFp(this.configuration).getSchoolForSection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific section
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    public getSection(id: string, options?: any) {
        return SectionsApiFp(this.configuration).getSection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of sections
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {'' | 'true'} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    public getSections(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options?: any) {
        return SectionsApiFp(this.configuration).getSections(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the students for a section
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    public getStudentsForSection(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any) {
        return SectionsApiFp(this.configuration).getStudentsForSection(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the primary teacher for a section
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    public getTeacherForSection(id: string, options?: any) {
        return SectionsApiFp(this.configuration).getTeacherForSection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the teachers for a section
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    public getTeachersForSection(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any) {
        return SectionsApiFp(this.configuration).getTeachersForSection(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the term for a section
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    public getTermForSection(id: string, options?: any) {
        return SectionsApiFp(this.configuration).getTermForSection(id, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * StudentsApi - axios parameter creator
 * @export
 */
export const StudentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the contacts for a student
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactsForStudent: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getContactsForStudent.');
            }
            const localVarPath = `/students/{id}/contacts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the district for a student
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForStudent: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDistrictForStudent.');
            }
            const localVarPath = `/students/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the primary school for a student
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolForStudent: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSchoolForStudent.');
            }
            const localVarPath = `/students/{id}/school`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the schools for a student
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolsForStudent: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSchoolsForStudent.');
            }
            const localVarPath = `/students/{id}/schools`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the sections for a student
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForStudent: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSectionsForStudent.');
            }
            const localVarPath = `/students/{id}/sections`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific student
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudent: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getStudent.');
            }
            const localVarPath = `/students/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of students
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudents: async (limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/students`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the teachers for a student
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachersForStudent: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTeachersForStudent.');
            }
            const localVarPath = `/students/{id}/teachers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudentsApi - functional programming interface
 * @export
 */
export const StudentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the contacts for a student
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContactsForStudent(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactsResponse>> {
            const localVarAxiosArgs = await StudentsApiAxiosParamCreator(configuration).getContactsForStudent(id, limit, startingAfter, endingBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the district for a student
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForStudent(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrictResponse>> {
            const localVarAxiosArgs = await StudentsApiAxiosParamCreator(configuration).getDistrictForStudent(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the primary school for a student
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolForStudent(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolResponse>> {
            const localVarAxiosArgs = await StudentsApiAxiosParamCreator(configuration).getSchoolForStudent(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the schools for a student
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolsForStudent(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolsResponse>> {
            const localVarAxiosArgs = await StudentsApiAxiosParamCreator(configuration).getSchoolsForStudent(id, limit, startingAfter, endingBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the sections for a student
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSectionsForStudent(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionsResponse>> {
            const localVarAxiosArgs = await StudentsApiAxiosParamCreator(configuration).getSectionsForStudent(id, limit, startingAfter, endingBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a specific student
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudent(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentResponse>> {
            const localVarAxiosArgs = await StudentsApiAxiosParamCreator(configuration).getStudent(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of students
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudents(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentsResponse>> {
            const localVarAxiosArgs = await StudentsApiAxiosParamCreator(configuration).getStudents(limit, startingAfter, endingBefore, count, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the teachers for a student
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeachersForStudent(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeachersResponse>> {
            const localVarAxiosArgs = await StudentsApiAxiosParamCreator(configuration).getTeachersForStudent(id, limit, startingAfter, endingBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StudentsApi - factory interface
 * @export
 */
export const StudentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns the contacts for a student
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactsForStudent(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<ContactsResponse> {
            return StudentsApiFp(configuration).getContactsForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the district for a student
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForStudent(id: string, options?: any): AxiosPromise<DistrictResponse> {
            return StudentsApiFp(configuration).getDistrictForStudent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the primary school for a student
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolForStudent(id: string, options?: any): AxiosPromise<SchoolResponse> {
            return StudentsApiFp(configuration).getSchoolForStudent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the schools for a student
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolsForStudent(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<SchoolsResponse> {
            return StudentsApiFp(configuration).getSchoolsForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the sections for a student
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForStudent(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<SectionsResponse> {
            return StudentsApiFp(configuration).getSectionsForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific student
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudent(id: string, options?: any): AxiosPromise<StudentResponse> {
            return StudentsApiFp(configuration).getStudent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of students
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudents(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options?: any): AxiosPromise<StudentsResponse> {
            return StudentsApiFp(configuration).getStudents(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the teachers for a student
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachersForStudent(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<TeachersResponse> {
            return StudentsApiFp(configuration).getTeachersForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudentsApi - object-oriented interface
 * @export
 * @class StudentsApi
 * @extends {BaseAPI}
 */
export class StudentsApi extends BaseAPI {
    /**
     * Returns the contacts for a student
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public getContactsForStudent(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any) {
        return StudentsApiFp(this.configuration).getContactsForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the district for a student
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public getDistrictForStudent(id: string, options?: any) {
        return StudentsApiFp(this.configuration).getDistrictForStudent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the primary school for a student
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public getSchoolForStudent(id: string, options?: any) {
        return StudentsApiFp(this.configuration).getSchoolForStudent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the schools for a student
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public getSchoolsForStudent(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any) {
        return StudentsApiFp(this.configuration).getSchoolsForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the sections for a student
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public getSectionsForStudent(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any) {
        return StudentsApiFp(this.configuration).getSectionsForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific student
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public getStudent(id: string, options?: any) {
        return StudentsApiFp(this.configuration).getStudent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of students
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {'' | 'true'} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public getStudents(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options?: any) {
        return StudentsApiFp(this.configuration).getStudents(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the teachers for a student
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public getTeachersForStudent(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any) {
        return StudentsApiFp(this.configuration).getTeachersForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TeachersApi - axios parameter creator
 * @export
 */
export const TeachersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the district for a teacher
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForTeacher: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDistrictForTeacher.');
            }
            const localVarPath = `/teachers/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves school info for a teacher.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolForTeacher: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSchoolForTeacher.');
            }
            const localVarPath = `/teachers/{id}/school`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the schools for a teacher
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolsForTeacher: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSchoolsForTeacher.');
            }
            const localVarPath = `/teachers/{id}/schools`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the sections for a teacher
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForTeacher: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSectionsForTeacher.');
            }
            const localVarPath = `/teachers/{id}/sections`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the students for a teacher
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForTeacher: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getStudentsForTeacher.');
            }
            const localVarPath = `/teachers/{id}/students`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific teacher
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeacher: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTeacher.');
            }
            const localVarPath = `/teachers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of teachers
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachers: async (limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/teachers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeachersApi - functional programming interface
 * @export
 */
export const TeachersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the district for a teacher
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForTeacher(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrictResponse>> {
            const localVarAxiosArgs = await TeachersApiAxiosParamCreator(configuration).getDistrictForTeacher(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves school info for a teacher.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolForTeacher(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolResponse>> {
            const localVarAxiosArgs = await TeachersApiAxiosParamCreator(configuration).getSchoolForTeacher(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the schools for a teacher
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolsForTeacher(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolsResponse>> {
            const localVarAxiosArgs = await TeachersApiAxiosParamCreator(configuration).getSchoolsForTeacher(id, limit, startingAfter, endingBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the sections for a teacher
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSectionsForTeacher(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionsResponse>> {
            const localVarAxiosArgs = await TeachersApiAxiosParamCreator(configuration).getSectionsForTeacher(id, limit, startingAfter, endingBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the students for a teacher
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudentsForTeacher(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentsResponse>> {
            const localVarAxiosArgs = await TeachersApiAxiosParamCreator(configuration).getStudentsForTeacher(id, limit, startingAfter, endingBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a specific teacher
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeacher(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeacherResponse>> {
            const localVarAxiosArgs = await TeachersApiAxiosParamCreator(configuration).getTeacher(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of teachers
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeachers(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeachersResponse>> {
            const localVarAxiosArgs = await TeachersApiAxiosParamCreator(configuration).getTeachers(limit, startingAfter, endingBefore, count, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TeachersApi - factory interface
 * @export
 */
export const TeachersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns the district for a teacher
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForTeacher(id: string, options?: any): AxiosPromise<DistrictResponse> {
            return TeachersApiFp(configuration).getDistrictForTeacher(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves school info for a teacher.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolForTeacher(id: string, options?: any): AxiosPromise<SchoolResponse> {
            return TeachersApiFp(configuration).getSchoolForTeacher(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the schools for a teacher
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolsForTeacher(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<SchoolsResponse> {
            return TeachersApiFp(configuration).getSchoolsForTeacher(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the sections for a teacher
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForTeacher(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<SectionsResponse> {
            return TeachersApiFp(configuration).getSectionsForTeacher(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the students for a teacher
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForTeacher(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<StudentsResponse> {
            return TeachersApiFp(configuration).getStudentsForTeacher(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific teacher
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeacher(id: string, options?: any): AxiosPromise<TeacherResponse> {
            return TeachersApiFp(configuration).getTeacher(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of teachers
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachers(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options?: any): AxiosPromise<TeachersResponse> {
            return TeachersApiFp(configuration).getTeachers(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeachersApi - object-oriented interface
 * @export
 * @class TeachersApi
 * @extends {BaseAPI}
 */
export class TeachersApi extends BaseAPI {
    /**
     * Returns the district for a teacher
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public getDistrictForTeacher(id: string, options?: any) {
        return TeachersApiFp(this.configuration).getDistrictForTeacher(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves school info for a teacher.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public getSchoolForTeacher(id: string, options?: any) {
        return TeachersApiFp(this.configuration).getSchoolForTeacher(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the schools for a teacher
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public getSchoolsForTeacher(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any) {
        return TeachersApiFp(this.configuration).getSchoolsForTeacher(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the sections for a teacher
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public getSectionsForTeacher(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any) {
        return TeachersApiFp(this.configuration).getSectionsForTeacher(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the students for a teacher
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public getStudentsForTeacher(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any) {
        return TeachersApiFp(this.configuration).getStudentsForTeacher(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific teacher
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public getTeacher(id: string, options?: any) {
        return TeachersApiFp(this.configuration).getTeacher(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of teachers
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {'' | 'true'} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public getTeachers(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options?: any) {
        return TeachersApiFp(this.configuration).getTeachers(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TermsApi - axios parameter creator
 * @export
 */
export const TermsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the district for a term
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForTerm: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDistrictForTerm.');
            }
            const localVarPath = `/terms/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the sections for a term
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForTerm: async (id: string, limit?: number, startingAfter?: string, endingBefore?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSectionsForTerm.');
            }
            const localVarPath = `/terms/{id}/sections`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific term
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerm: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTerm.');
            }
            const localVarPath = `/terms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of terms
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerms: async (limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/terms`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TermsApi - functional programming interface
 * @export
 */
export const TermsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the district for a term
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForTerm(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrictResponse>> {
            const localVarAxiosArgs = await TermsApiAxiosParamCreator(configuration).getDistrictForTerm(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the sections for a term
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSectionsForTerm(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionsResponse>> {
            const localVarAxiosArgs = await TermsApiAxiosParamCreator(configuration).getSectionsForTerm(id, limit, startingAfter, endingBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a specific term
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTerm(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TermResponse>> {
            const localVarAxiosArgs = await TermsApiAxiosParamCreator(configuration).getTerm(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of terms
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTerms(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TermsResponse>> {
            const localVarAxiosArgs = await TermsApiAxiosParamCreator(configuration).getTerms(limit, startingAfter, endingBefore, count, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TermsApi - factory interface
 * @export
 */
export const TermsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns the district for a term
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForTerm(id: string, options?: any): AxiosPromise<DistrictResponse> {
            return TermsApiFp(configuration).getDistrictForTerm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the sections for a term
         * @param {string} id 
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForTerm(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any): AxiosPromise<SectionsResponse> {
            return TermsApiFp(configuration).getSectionsForTerm(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific term
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerm(id: string, options?: any): AxiosPromise<TermResponse> {
            return TermsApiFp(configuration).getTerm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of terms
         * @param {number} [limit] 
         * @param {string} [startingAfter] 
         * @param {string} [endingBefore] 
         * @param {'' | 'true'} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerms(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options?: any): AxiosPromise<TermsResponse> {
            return TermsApiFp(configuration).getTerms(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TermsApi - object-oriented interface
 * @export
 * @class TermsApi
 * @extends {BaseAPI}
 */
export class TermsApi extends BaseAPI {
    /**
     * Returns the district for a term
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermsApi
     */
    public getDistrictForTerm(id: string, options?: any) {
        return TermsApiFp(this.configuration).getDistrictForTerm(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the sections for a term
     * @param {string} id 
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermsApi
     */
    public getSectionsForTerm(id: string, limit?: number, startingAfter?: string, endingBefore?: string, options?: any) {
        return TermsApiFp(this.configuration).getSectionsForTerm(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific term
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermsApi
     */
    public getTerm(id: string, options?: any) {
        return TermsApiFp(this.configuration).getTerm(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of terms
     * @param {number} [limit] 
     * @param {string} [startingAfter] 
     * @param {string} [endingBefore] 
     * @param {'' | 'true'} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermsApi
     */
    public getTerms(limit?: number, startingAfter?: string, endingBefore?: string, count?: '' | 'true', options?: any) {
        return TermsApiFp(this.configuration).getTerms(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }

}


