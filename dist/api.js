"use strict";
// tslint:disable
/**
 * Data API
 * Serves the Clever Data API
 *
 * The version of the OpenAPI document: 2.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TermsApi = exports.TermsApiFactory = exports.TermsApiFp = exports.TermsApiAxiosParamCreator = exports.TeachersApi = exports.TeachersApiFactory = exports.TeachersApiFp = exports.TeachersApiAxiosParamCreator = exports.StudentsApi = exports.StudentsApiFactory = exports.StudentsApiFp = exports.StudentsApiAxiosParamCreator = exports.SectionsApi = exports.SectionsApiFactory = exports.SectionsApiFp = exports.SectionsApiAxiosParamCreator = exports.SchoolsApi = exports.SchoolsApiFactory = exports.SchoolsApiFp = exports.SchoolsApiAxiosParamCreator = exports.SchoolAdminsApi = exports.SchoolAdminsApiFactory = exports.SchoolAdminsApiFp = exports.SchoolAdminsApiAxiosParamCreator = exports.EventsApi = exports.EventsApiFactory = exports.EventsApiFp = exports.EventsApiAxiosParamCreator = exports.DistrictsApi = exports.DistrictsApiFactory = exports.DistrictsApiFp = exports.DistrictsApiAxiosParamCreator = exports.DistrictAdminsApi = exports.DistrictAdminsApiFactory = exports.DistrictAdminsApiFp = exports.DistrictAdminsApiAxiosParamCreator = exports.CoursesApi = exports.CoursesApiFactory = exports.CoursesApiFp = exports.CoursesApiAxiosParamCreator = exports.ContactsApi = exports.ContactsApiFactory = exports.ContactsApiFp = exports.ContactsApiAxiosParamCreator = exports.StudentRaceEnum = exports.StudentHomeLanguageEnum = exports.StudentHispanicEthnicityEnum = exports.StudentGradeEnum = exports.StudentGenderEnum = exports.StudentEllStatusEnum = exports.SectionSubjectEnum = exports.SectionGradeEnum = exports.SchoolLowGradeEnum = exports.SchoolHighGradeEnum = exports.LinkRelEnum = exports.DistrictStateEnum = exports.ContactTypeEnum = exports.ContactRelationshipEnum = exports.ContactPhoneTypeEnum = void 0;
const globalImportUrl = require("url");
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const base_1 = require("./base");
/**
    * @export
    * @enum {string}
    */
var ContactPhoneTypeEnum;
(function (ContactPhoneTypeEnum) {
    ContactPhoneTypeEnum["Cell"] = "Cell";
    ContactPhoneTypeEnum["Home"] = "Home";
    ContactPhoneTypeEnum["Work"] = "Work";
    ContactPhoneTypeEnum["Other"] = "Other";
    ContactPhoneTypeEnum["Empty"] = "";
})(ContactPhoneTypeEnum = exports.ContactPhoneTypeEnum || (exports.ContactPhoneTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ContactRelationshipEnum;
(function (ContactRelationshipEnum) {
    ContactRelationshipEnum["Parent"] = "Parent";
    ContactRelationshipEnum["Grandparent"] = "Grandparent";
    ContactRelationshipEnum["Self"] = "Self";
    ContactRelationshipEnum["AuntUncle"] = "Aunt/Uncle";
    ContactRelationshipEnum["Sibling"] = "Sibling";
    ContactRelationshipEnum["Other"] = "Other";
    ContactRelationshipEnum["Empty"] = "";
})(ContactRelationshipEnum = exports.ContactRelationshipEnum || (exports.ContactRelationshipEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ContactTypeEnum;
(function (ContactTypeEnum) {
    ContactTypeEnum["ParentGuardian"] = "Parent/Guardian";
    ContactTypeEnum["Emergency"] = "Emergency";
    ContactTypeEnum["Primary"] = "Primary";
    ContactTypeEnum["Secondary"] = "Secondary";
    ContactTypeEnum["Family"] = "Family";
    ContactTypeEnum["Other"] = "Other";
    ContactTypeEnum["Empty"] = "";
})(ContactTypeEnum = exports.ContactTypeEnum || (exports.ContactTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var DistrictStateEnum;
(function (DistrictStateEnum) {
    DistrictStateEnum["Running"] = "running";
    DistrictStateEnum["Pending"] = "pending";
    DistrictStateEnum["Error"] = "error";
    DistrictStateEnum["Paused"] = "paused";
    DistrictStateEnum["Empty"] = "";
})(DistrictStateEnum = exports.DistrictStateEnum || (exports.DistrictStateEnum = {}));
/**
    * @export
    * @enum {string}
    */
var LinkRelEnum;
(function (LinkRelEnum) {
    LinkRelEnum["Next"] = "next";
    LinkRelEnum["Prev"] = "prev";
    LinkRelEnum["Self"] = "self";
})(LinkRelEnum = exports.LinkRelEnum || (exports.LinkRelEnum = {}));
/**
    * @export
    * @enum {string}
    */
var SchoolHighGradeEnum;
(function (SchoolHighGradeEnum) {
    SchoolHighGradeEnum["InfantToddler"] = "InfantToddler";
    SchoolHighGradeEnum["Preschool"] = "Preschool";
    SchoolHighGradeEnum["PreKindergarten"] = "PreKindergarten";
    SchoolHighGradeEnum["TransitionalKindergarten"] = "TransitionalKindergarten";
    SchoolHighGradeEnum["Kindergarten"] = "Kindergarten";
    SchoolHighGradeEnum["_1"] = "1";
    SchoolHighGradeEnum["_2"] = "2";
    SchoolHighGradeEnum["_3"] = "3";
    SchoolHighGradeEnum["_4"] = "4";
    SchoolHighGradeEnum["_5"] = "5";
    SchoolHighGradeEnum["_6"] = "6";
    SchoolHighGradeEnum["_7"] = "7";
    SchoolHighGradeEnum["_8"] = "8";
    SchoolHighGradeEnum["_9"] = "9";
    SchoolHighGradeEnum["_10"] = "10";
    SchoolHighGradeEnum["_11"] = "11";
    SchoolHighGradeEnum["_12"] = "12";
    SchoolHighGradeEnum["_13"] = "13";
    SchoolHighGradeEnum["PostGraduate"] = "PostGraduate";
    SchoolHighGradeEnum["Ungraded"] = "Ungraded";
    SchoolHighGradeEnum["Other"] = "Other";
    SchoolHighGradeEnum["Empty"] = "";
})(SchoolHighGradeEnum = exports.SchoolHighGradeEnum || (exports.SchoolHighGradeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var SchoolLowGradeEnum;
(function (SchoolLowGradeEnum) {
    SchoolLowGradeEnum["InfantToddler"] = "InfantToddler";
    SchoolLowGradeEnum["Preschool"] = "Preschool";
    SchoolLowGradeEnum["PreKindergarten"] = "PreKindergarten";
    SchoolLowGradeEnum["TransitionalKindergarten"] = "TransitionalKindergarten";
    SchoolLowGradeEnum["Kindergarten"] = "Kindergarten";
    SchoolLowGradeEnum["_1"] = "1";
    SchoolLowGradeEnum["_2"] = "2";
    SchoolLowGradeEnum["_3"] = "3";
    SchoolLowGradeEnum["_4"] = "4";
    SchoolLowGradeEnum["_5"] = "5";
    SchoolLowGradeEnum["_6"] = "6";
    SchoolLowGradeEnum["_7"] = "7";
    SchoolLowGradeEnum["_8"] = "8";
    SchoolLowGradeEnum["_9"] = "9";
    SchoolLowGradeEnum["_10"] = "10";
    SchoolLowGradeEnum["_11"] = "11";
    SchoolLowGradeEnum["_12"] = "12";
    SchoolLowGradeEnum["_13"] = "13";
    SchoolLowGradeEnum["PostGraduate"] = "PostGraduate";
    SchoolLowGradeEnum["Ungraded"] = "Ungraded";
    SchoolLowGradeEnum["Other"] = "Other";
    SchoolLowGradeEnum["Empty"] = "";
})(SchoolLowGradeEnum = exports.SchoolLowGradeEnum || (exports.SchoolLowGradeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var SectionGradeEnum;
(function (SectionGradeEnum) {
    SectionGradeEnum["InfantToddler"] = "InfantToddler";
    SectionGradeEnum["Preschool"] = "Preschool";
    SectionGradeEnum["PreKindergarten"] = "PreKindergarten";
    SectionGradeEnum["TransitionalKindergarten"] = "TransitionalKindergarten";
    SectionGradeEnum["Kindergarten"] = "Kindergarten";
    SectionGradeEnum["_1"] = "1";
    SectionGradeEnum["_2"] = "2";
    SectionGradeEnum["_3"] = "3";
    SectionGradeEnum["_4"] = "4";
    SectionGradeEnum["_5"] = "5";
    SectionGradeEnum["_6"] = "6";
    SectionGradeEnum["_7"] = "7";
    SectionGradeEnum["_8"] = "8";
    SectionGradeEnum["_9"] = "9";
    SectionGradeEnum["_10"] = "10";
    SectionGradeEnum["_11"] = "11";
    SectionGradeEnum["_12"] = "12";
    SectionGradeEnum["_13"] = "13";
    SectionGradeEnum["PostGraduate"] = "PostGraduate";
    SectionGradeEnum["Ungraded"] = "Ungraded";
    SectionGradeEnum["Other"] = "Other";
    SectionGradeEnum["Empty"] = "";
})(SectionGradeEnum = exports.SectionGradeEnum || (exports.SectionGradeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var SectionSubjectEnum;
(function (SectionSubjectEnum) {
    SectionSubjectEnum["EnglishLanguageArts"] = "english/language arts";
    SectionSubjectEnum["Math"] = "math";
    SectionSubjectEnum["Science"] = "science";
    SectionSubjectEnum["SocialStudies"] = "social studies";
    SectionSubjectEnum["Language"] = "language";
    SectionSubjectEnum["HomeroomAdvisory"] = "homeroom/advisory";
    SectionSubjectEnum["InterventionsOnlineLearning"] = "interventions/online learning";
    SectionSubjectEnum["TechnologyAndEngineering"] = "technology and engineering";
    SectionSubjectEnum["PEAndHealth"] = "PE and health";
    SectionSubjectEnum["ArtsAndMusic"] = "arts and music";
    SectionSubjectEnum["Other"] = "other";
    SectionSubjectEnum["Empty"] = "";
})(SectionSubjectEnum = exports.SectionSubjectEnum || (exports.SectionSubjectEnum = {}));
/**
    * @export
    * @enum {string}
    */
var StudentEllStatusEnum;
(function (StudentEllStatusEnum) {
    StudentEllStatusEnum["Y"] = "Y";
    StudentEllStatusEnum["N"] = "N";
    StudentEllStatusEnum["Empty"] = "";
})(StudentEllStatusEnum = exports.StudentEllStatusEnum || (exports.StudentEllStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var StudentGenderEnum;
(function (StudentGenderEnum) {
    StudentGenderEnum["M"] = "M";
    StudentGenderEnum["F"] = "F";
    StudentGenderEnum["X"] = "X";
    StudentGenderEnum["Empty"] = "";
})(StudentGenderEnum = exports.StudentGenderEnum || (exports.StudentGenderEnum = {}));
/**
    * @export
    * @enum {string}
    */
var StudentGradeEnum;
(function (StudentGradeEnum) {
    StudentGradeEnum["InfantToddler"] = "InfantToddler";
    StudentGradeEnum["Preschool"] = "Preschool";
    StudentGradeEnum["PreKindergarten"] = "PreKindergarten";
    StudentGradeEnum["TransitionalKindergarten"] = "TransitionalKindergarten";
    StudentGradeEnum["Kindergarten"] = "Kindergarten";
    StudentGradeEnum["_1"] = "1";
    StudentGradeEnum["_2"] = "2";
    StudentGradeEnum["_3"] = "3";
    StudentGradeEnum["_4"] = "4";
    StudentGradeEnum["_5"] = "5";
    StudentGradeEnum["_6"] = "6";
    StudentGradeEnum["_7"] = "7";
    StudentGradeEnum["_8"] = "8";
    StudentGradeEnum["_9"] = "9";
    StudentGradeEnum["_10"] = "10";
    StudentGradeEnum["_11"] = "11";
    StudentGradeEnum["_12"] = "12";
    StudentGradeEnum["_13"] = "13";
    StudentGradeEnum["PostGraduate"] = "PostGraduate";
    StudentGradeEnum["Ungraded"] = "Ungraded";
    StudentGradeEnum["Other"] = "Other";
    StudentGradeEnum["Empty"] = "";
})(StudentGradeEnum = exports.StudentGradeEnum || (exports.StudentGradeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var StudentHispanicEthnicityEnum;
(function (StudentHispanicEthnicityEnum) {
    StudentHispanicEthnicityEnum["Y"] = "Y";
    StudentHispanicEthnicityEnum["N"] = "N";
    StudentHispanicEthnicityEnum["Empty"] = "";
})(StudentHispanicEthnicityEnum = exports.StudentHispanicEthnicityEnum || (exports.StudentHispanicEthnicityEnum = {}));
/**
    * @export
    * @enum {string}
    */
var StudentHomeLanguageEnum;
(function (StudentHomeLanguageEnum) {
    StudentHomeLanguageEnum["English"] = "English";
    StudentHomeLanguageEnum["Albanian"] = "Albanian";
    StudentHomeLanguageEnum["Amharic"] = "Amharic";
    StudentHomeLanguageEnum["Arabic"] = "Arabic";
    StudentHomeLanguageEnum["Bengali"] = "Bengali";
    StudentHomeLanguageEnum["Bosnian"] = "Bosnian";
    StudentHomeLanguageEnum["Burmese"] = "Burmese";
    StudentHomeLanguageEnum["Cantonese"] = "Cantonese";
    StudentHomeLanguageEnum["Chinese"] = "Chinese";
    StudentHomeLanguageEnum["Dutch"] = "Dutch";
    StudentHomeLanguageEnum["Farsi"] = "Farsi";
    StudentHomeLanguageEnum["French"] = "French";
    StudentHomeLanguageEnum["German"] = "German";
    StudentHomeLanguageEnum["Hebrew"] = "Hebrew";
    StudentHomeLanguageEnum["Hindi"] = "Hindi";
    StudentHomeLanguageEnum["Hmong"] = "Hmong";
    StudentHomeLanguageEnum["Ilocano"] = "Ilocano";
    StudentHomeLanguageEnum["Japanese"] = "Japanese";
    StudentHomeLanguageEnum["Javanese"] = "Javanese";
    StudentHomeLanguageEnum["Karen"] = "Karen";
    StudentHomeLanguageEnum["Khmer"] = "Khmer";
    StudentHomeLanguageEnum["Korean"] = "Korean";
    StudentHomeLanguageEnum["Laotian"] = "Laotian";
    StudentHomeLanguageEnum["Latvian"] = "Latvian";
    StudentHomeLanguageEnum["Malay"] = "Malay";
    StudentHomeLanguageEnum["Mandarin"] = "Mandarin";
    StudentHomeLanguageEnum["Nepali"] = "Nepali";
    StudentHomeLanguageEnum["Oromo"] = "Oromo";
    StudentHomeLanguageEnum["Polish"] = "Polish";
    StudentHomeLanguageEnum["Portuguese"] = "Portuguese";
    StudentHomeLanguageEnum["Punjabi"] = "Punjabi";
    StudentHomeLanguageEnum["Romanian"] = "Romanian";
    StudentHomeLanguageEnum["Russian"] = "Russian";
    StudentHomeLanguageEnum["Samoan"] = "Samoan";
    StudentHomeLanguageEnum["Serbian"] = "Serbian";
    StudentHomeLanguageEnum["Somali"] = "Somali";
    StudentHomeLanguageEnum["Spanish"] = "Spanish";
    StudentHomeLanguageEnum["Swahili"] = "Swahili";
    StudentHomeLanguageEnum["Tagalog"] = "Tagalog";
    StudentHomeLanguageEnum["Tamil"] = "Tamil";
    StudentHomeLanguageEnum["Telugu"] = "Telugu";
    StudentHomeLanguageEnum["Thai"] = "Thai";
    StudentHomeLanguageEnum["Tigrinya"] = "Tigrinya";
    StudentHomeLanguageEnum["Turkish"] = "Turkish";
    StudentHomeLanguageEnum["Ukrainian"] = "Ukrainian";
    StudentHomeLanguageEnum["Urdu"] = "Urdu";
    StudentHomeLanguageEnum["Vietnamese"] = "Vietnamese";
    StudentHomeLanguageEnum["Empty"] = "";
})(StudentHomeLanguageEnum = exports.StudentHomeLanguageEnum || (exports.StudentHomeLanguageEnum = {}));
/**
    * @export
    * @enum {string}
    */
var StudentRaceEnum;
(function (StudentRaceEnum) {
    StudentRaceEnum["Caucasian"] = "Caucasian";
    StudentRaceEnum["Asian"] = "Asian";
    StudentRaceEnum["BlackOrAfricanAmerican"] = "Black or African American";
    StudentRaceEnum["AmericanIndian"] = "American Indian";
    StudentRaceEnum["HawaiianOrOtherPacificIslander"] = "Hawaiian or Other Pacific Islander";
    StudentRaceEnum["TwoOrMoreRaces"] = "Two or More Races";
    StudentRaceEnum["Unknown"] = "Unknown";
    StudentRaceEnum["Empty"] = "";
})(StudentRaceEnum = exports.StudentRaceEnum || (exports.StudentRaceEnum = {}));
/**
 * ContactsApi - axios parameter creator
 * @export
 */
exports.ContactsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a specific student contact
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContact: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getContact.');
            }
            const localVarPath = `/contacts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of student contacts
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContacts: async (limit, startingAfter, endingBefore, count, options = {}) => {
            const localVarPath = `/contacts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the district for a student contact
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForContact: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getDistrictForContact.');
            }
            const localVarPath = `/contacts/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the students for a student contact
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForContact: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getStudentsForContact.');
            }
            const localVarPath = `/contacts/{id}/students`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ContactsApi - functional programming interface
 * @export
 */
exports.ContactsApiFp = function (configuration) {
    return {
        /**
         * Returns a specific student contact
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContact(id, options) {
            const localVarAxiosArgs = await exports.ContactsApiAxiosParamCreator(configuration).getContact(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of student contacts
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContacts(limit, startingAfter, endingBefore, count, options) {
            const localVarAxiosArgs = await exports.ContactsApiAxiosParamCreator(configuration).getContacts(limit, startingAfter, endingBefore, count, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the district for a student contact
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForContact(id, options) {
            const localVarAxiosArgs = await exports.ContactsApiAxiosParamCreator(configuration).getDistrictForContact(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the students for a student contact
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudentsForContact(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await exports.ContactsApiAxiosParamCreator(configuration).getStudentsForContact(id, limit, startingAfter, endingBefore, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * ContactsApi - factory interface
 * @export
 */
exports.ContactsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Returns a specific student contact
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContact(id, options) {
            return exports.ContactsApiFp(configuration).getContact(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of student contacts
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContacts(limit, startingAfter, endingBefore, count, options) {
            return exports.ContactsApiFp(configuration).getContacts(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the district for a student contact
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForContact(id, options) {
            return exports.ContactsApiFp(configuration).getDistrictForContact(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the students for a student contact
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForContact(id, limit, startingAfter, endingBefore, options) {
            return exports.ContactsApiFp(configuration).getStudentsForContact(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ContactsApi - object-oriented interface
 * @export
 * @class ContactsApi
 * @extends {BaseAPI}
 */
class ContactsApi extends base_1.BaseAPI {
    /**
     * Returns a specific student contact
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    getContact(id, options) {
        return exports.ContactsApiFp(this.configuration).getContact(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of student contacts
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {'' | 'true'} [count]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    getContacts(limit, startingAfter, endingBefore, count, options) {
        return exports.ContactsApiFp(this.configuration).getContacts(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the district for a student contact
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    getDistrictForContact(id, options) {
        return exports.ContactsApiFp(this.configuration).getDistrictForContact(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the students for a student contact
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    getStudentsForContact(id, limit, startingAfter, endingBefore, options) {
        return exports.ContactsApiFp(this.configuration).getStudentsForContact(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ContactsApi = ContactsApi;
/**
 * CoursesApi - axios parameter creator
 * @export
 */
exports.CoursesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a specific course
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourse: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getCourse.');
            }
            const localVarPath = `/courses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of courses
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourses: async (limit, startingAfter, endingBefore, count, options = {}) => {
            const localVarPath = `/courses`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the district for a course
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForCourse: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getDistrictForCourse.');
            }
            const localVarPath = `/courses/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the sections for a Courses
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForCourse: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getSectionsForCourse.');
            }
            const localVarPath = `/courses/{id}/sections`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CoursesApi - functional programming interface
 * @export
 */
exports.CoursesApiFp = function (configuration) {
    return {
        /**
         * Returns a specific course
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourse(id, options) {
            const localVarAxiosArgs = await exports.CoursesApiAxiosParamCreator(configuration).getCourse(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of courses
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourses(limit, startingAfter, endingBefore, count, options) {
            const localVarAxiosArgs = await exports.CoursesApiAxiosParamCreator(configuration).getCourses(limit, startingAfter, endingBefore, count, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the district for a course
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForCourse(id, options) {
            const localVarAxiosArgs = await exports.CoursesApiAxiosParamCreator(configuration).getDistrictForCourse(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the sections for a Courses
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSectionsForCourse(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await exports.CoursesApiAxiosParamCreator(configuration).getSectionsForCourse(id, limit, startingAfter, endingBefore, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * CoursesApi - factory interface
 * @export
 */
exports.CoursesApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Returns a specific course
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourse(id, options) {
            return exports.CoursesApiFp(configuration).getCourse(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of courses
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourses(limit, startingAfter, endingBefore, count, options) {
            return exports.CoursesApiFp(configuration).getCourses(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the district for a course
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForCourse(id, options) {
            return exports.CoursesApiFp(configuration).getDistrictForCourse(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the sections for a Courses
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForCourse(id, limit, startingAfter, endingBefore, options) {
            return exports.CoursesApiFp(configuration).getSectionsForCourse(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CoursesApi - object-oriented interface
 * @export
 * @class CoursesApi
 * @extends {BaseAPI}
 */
class CoursesApi extends base_1.BaseAPI {
    /**
     * Returns a specific course
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    getCourse(id, options) {
        return exports.CoursesApiFp(this.configuration).getCourse(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of courses
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {'' | 'true'} [count]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    getCourses(limit, startingAfter, endingBefore, count, options) {
        return exports.CoursesApiFp(this.configuration).getCourses(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the district for a course
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    getDistrictForCourse(id, options) {
        return exports.CoursesApiFp(this.configuration).getDistrictForCourse(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the sections for a Courses
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    getSectionsForCourse(id, limit, startingAfter, endingBefore, options) {
        return exports.CoursesApiFp(this.configuration).getSectionsForCourse(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CoursesApi = CoursesApi;
/**
 * DistrictAdminsApi - axios parameter creator
 * @export
 */
exports.DistrictAdminsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a specific district admin
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictAdmin: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getDistrictAdmin.');
            }
            const localVarPath = `/district_admins/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of district admins
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictAdmins: async (limit, startingAfter, endingBefore, count, options = {}) => {
            const localVarPath = `/district_admins`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the district for a district admin
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForDistrictAdmin: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getDistrictForDistrictAdmin.');
            }
            const localVarPath = `/district_admins/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * DistrictAdminsApi - functional programming interface
 * @export
 */
exports.DistrictAdminsApiFp = function (configuration) {
    return {
        /**
         * Returns a specific district admin
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictAdmin(id, options) {
            const localVarAxiosArgs = await exports.DistrictAdminsApiAxiosParamCreator(configuration).getDistrictAdmin(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of district admins
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictAdmins(limit, startingAfter, endingBefore, count, options) {
            const localVarAxiosArgs = await exports.DistrictAdminsApiAxiosParamCreator(configuration).getDistrictAdmins(limit, startingAfter, endingBefore, count, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the district for a district admin
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForDistrictAdmin(id, options) {
            const localVarAxiosArgs = await exports.DistrictAdminsApiAxiosParamCreator(configuration).getDistrictForDistrictAdmin(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * DistrictAdminsApi - factory interface
 * @export
 */
exports.DistrictAdminsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Returns a specific district admin
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictAdmin(id, options) {
            return exports.DistrictAdminsApiFp(configuration).getDistrictAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of district admins
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictAdmins(limit, startingAfter, endingBefore, count, options) {
            return exports.DistrictAdminsApiFp(configuration).getDistrictAdmins(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the district for a district admin
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForDistrictAdmin(id, options) {
            return exports.DistrictAdminsApiFp(configuration).getDistrictForDistrictAdmin(id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DistrictAdminsApi - object-oriented interface
 * @export
 * @class DistrictAdminsApi
 * @extends {BaseAPI}
 */
class DistrictAdminsApi extends base_1.BaseAPI {
    /**
     * Returns a specific district admin
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictAdminsApi
     */
    getDistrictAdmin(id, options) {
        return exports.DistrictAdminsApiFp(this.configuration).getDistrictAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of district admins
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {'' | 'true'} [count]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictAdminsApi
     */
    getDistrictAdmins(limit, startingAfter, endingBefore, count, options) {
        return exports.DistrictAdminsApiFp(this.configuration).getDistrictAdmins(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the district for a district admin
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictAdminsApi
     */
    getDistrictForDistrictAdmin(id, options) {
        return exports.DistrictAdminsApiFp(this.configuration).getDistrictForDistrictAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.DistrictAdminsApi = DistrictAdminsApi;
/**
 * DistrictsApi - axios parameter creator
 * @export
 */
exports.DistrictsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a specific district
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrict: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getDistrict.');
            }
            const localVarPath = `/districts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of districts
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistricts: async (count, options = {}) => {
            const localVarPath = `/districts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * DistrictsApi - functional programming interface
 * @export
 */
exports.DistrictsApiFp = function (configuration) {
    return {
        /**
         * Returns a specific district
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrict(id, options) {
            const localVarAxiosArgs = await exports.DistrictsApiAxiosParamCreator(configuration).getDistrict(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of districts
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistricts(count, options) {
            const localVarAxiosArgs = await exports.DistrictsApiAxiosParamCreator(configuration).getDistricts(count, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * DistrictsApi - factory interface
 * @export
 */
exports.DistrictsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Returns a specific district
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrict(id, options) {
            return exports.DistrictsApiFp(configuration).getDistrict(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of districts
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistricts(count, options) {
            return exports.DistrictsApiFp(configuration).getDistricts(count, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DistrictsApi - object-oriented interface
 * @export
 * @class DistrictsApi
 * @extends {BaseAPI}
 */
class DistrictsApi extends base_1.BaseAPI {
    /**
     * Returns a specific district
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictsApi
     */
    getDistrict(id, options) {
        return exports.DistrictsApiFp(this.configuration).getDistrict(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of districts
     * @param {'' | 'true'} [count]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictsApi
     */
    getDistricts(count, options) {
        return exports.DistrictsApiFp(this.configuration).getDistricts(count, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.DistrictsApi = DistrictsApi;
/**
 * EventsApi - axios parameter creator
 * @export
 */
exports.EventsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the specific event
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getEvent.');
            }
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of events
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {string} [school]
         * @param {Array<string>} [recordType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (limit, startingAfter, endingBefore, school, recordType, options = {}) => {
            const localVarPath = `/events`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            if (school !== undefined) {
                localVarQueryParameter['school'] = school;
            }
            if (recordType) {
                localVarQueryParameter['record_type'] = recordType;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * EventsApi - functional programming interface
 * @export
 */
exports.EventsApiFp = function (configuration) {
    return {
        /**
         * Returns the specific event
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvent(id, options) {
            const localVarAxiosArgs = await exports.EventsApiAxiosParamCreator(configuration).getEvent(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of events
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {string} [school]
         * @param {Array<string>} [recordType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(limit, startingAfter, endingBefore, school, recordType, options) {
            const localVarAxiosArgs = await exports.EventsApiAxiosParamCreator(configuration).getEvents(limit, startingAfter, endingBefore, school, recordType, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * EventsApi - factory interface
 * @export
 */
exports.EventsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Returns the specific event
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(id, options) {
            return exports.EventsApiFp(configuration).getEvent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of events
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {string} [school]
         * @param {Array<string>} [recordType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(limit, startingAfter, endingBefore, school, recordType, options) {
            return exports.EventsApiFp(configuration).getEvents(limit, startingAfter, endingBefore, school, recordType, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
class EventsApi extends base_1.BaseAPI {
    /**
     * Returns the specific event
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    getEvent(id, options) {
        return exports.EventsApiFp(this.configuration).getEvent(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of events
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {string} [school]
     * @param {Array<string>} [recordType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    getEvents(limit, startingAfter, endingBefore, school, recordType, options) {
        return exports.EventsApiFp(this.configuration).getEvents(limit, startingAfter, endingBefore, school, recordType, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.EventsApi = EventsApi;
/**
 * SchoolAdminsApi - axios parameter creator
 * @export
 */
exports.SchoolAdminsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the district for a school admin
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForSchoolAdmin: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getDistrictForSchoolAdmin.');
            }
            const localVarPath = `/school_admins/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific school admin
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolAdmin: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getSchoolAdmin.');
            }
            const localVarPath = `/school_admins/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of school admins
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolAdmins: async (limit, startingAfter, endingBefore, count, options = {}) => {
            const localVarPath = `/school_admins`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the schools for a school admin
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolsForSchoolAdmin: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getSchoolsForSchoolAdmin.');
            }
            const localVarPath = `/school_admins/{id}/schools`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SchoolAdminsApi - functional programming interface
 * @export
 */
exports.SchoolAdminsApiFp = function (configuration) {
    return {
        /**
         * Returns the district for a school admin
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForSchoolAdmin(id, options) {
            const localVarAxiosArgs = await exports.SchoolAdminsApiAxiosParamCreator(configuration).getDistrictForSchoolAdmin(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a specific school admin
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolAdmin(id, options) {
            const localVarAxiosArgs = await exports.SchoolAdminsApiAxiosParamCreator(configuration).getSchoolAdmin(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of school admins
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolAdmins(limit, startingAfter, endingBefore, count, options) {
            const localVarAxiosArgs = await exports.SchoolAdminsApiAxiosParamCreator(configuration).getSchoolAdmins(limit, startingAfter, endingBefore, count, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the schools for a school admin
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolsForSchoolAdmin(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await exports.SchoolAdminsApiAxiosParamCreator(configuration).getSchoolsForSchoolAdmin(id, limit, startingAfter, endingBefore, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * SchoolAdminsApi - factory interface
 * @export
 */
exports.SchoolAdminsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Returns the district for a school admin
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForSchoolAdmin(id, options) {
            return exports.SchoolAdminsApiFp(configuration).getDistrictForSchoolAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific school admin
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolAdmin(id, options) {
            return exports.SchoolAdminsApiFp(configuration).getSchoolAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of school admins
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolAdmins(limit, startingAfter, endingBefore, count, options) {
            return exports.SchoolAdminsApiFp(configuration).getSchoolAdmins(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the schools for a school admin
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolsForSchoolAdmin(id, limit, startingAfter, endingBefore, options) {
            return exports.SchoolAdminsApiFp(configuration).getSchoolsForSchoolAdmin(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SchoolAdminsApi - object-oriented interface
 * @export
 * @class SchoolAdminsApi
 * @extends {BaseAPI}
 */
class SchoolAdminsApi extends base_1.BaseAPI {
    /**
     * Returns the district for a school admin
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolAdminsApi
     */
    getDistrictForSchoolAdmin(id, options) {
        return exports.SchoolAdminsApiFp(this.configuration).getDistrictForSchoolAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a specific school admin
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolAdminsApi
     */
    getSchoolAdmin(id, options) {
        return exports.SchoolAdminsApiFp(this.configuration).getSchoolAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of school admins
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {'' | 'true'} [count]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolAdminsApi
     */
    getSchoolAdmins(limit, startingAfter, endingBefore, count, options) {
        return exports.SchoolAdminsApiFp(this.configuration).getSchoolAdmins(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the schools for a school admin
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolAdminsApi
     */
    getSchoolsForSchoolAdmin(id, limit, startingAfter, endingBefore, options) {
        return exports.SchoolAdminsApiFp(this.configuration).getSchoolsForSchoolAdmin(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SchoolAdminsApi = SchoolAdminsApi;
/**
 * SchoolsApi - axios parameter creator
 * @export
 */
exports.SchoolsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the district for a school
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForSchool: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getDistrictForSchool.');
            }
            const localVarPath = `/schools/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific school
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchool: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getSchool.');
            }
            const localVarPath = `/schools/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of schools
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchools: async (limit, startingAfter, endingBefore, count, options = {}) => {
            const localVarPath = `/schools`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the sections for a school
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForSchool: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getSectionsForSchool.');
            }
            const localVarPath = `/schools/{id}/sections`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the students for a school
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForSchool: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getStudentsForSchool.');
            }
            const localVarPath = `/schools/{id}/students`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the teachers for a school
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachersForSchool: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getTeachersForSchool.');
            }
            const localVarPath = `/schools/{id}/teachers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SchoolsApi - functional programming interface
 * @export
 */
exports.SchoolsApiFp = function (configuration) {
    return {
        /**
         * Returns the district for a school
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForSchool(id, options) {
            const localVarAxiosArgs = await exports.SchoolsApiAxiosParamCreator(configuration).getDistrictForSchool(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a specific school
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchool(id, options) {
            const localVarAxiosArgs = await exports.SchoolsApiAxiosParamCreator(configuration).getSchool(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of schools
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchools(limit, startingAfter, endingBefore, count, options) {
            const localVarAxiosArgs = await exports.SchoolsApiAxiosParamCreator(configuration).getSchools(limit, startingAfter, endingBefore, count, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the sections for a school
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSectionsForSchool(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await exports.SchoolsApiAxiosParamCreator(configuration).getSectionsForSchool(id, limit, startingAfter, endingBefore, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the students for a school
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudentsForSchool(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await exports.SchoolsApiAxiosParamCreator(configuration).getStudentsForSchool(id, limit, startingAfter, endingBefore, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the teachers for a school
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeachersForSchool(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await exports.SchoolsApiAxiosParamCreator(configuration).getTeachersForSchool(id, limit, startingAfter, endingBefore, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * SchoolsApi - factory interface
 * @export
 */
exports.SchoolsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Returns the district for a school
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForSchool(id, options) {
            return exports.SchoolsApiFp(configuration).getDistrictForSchool(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific school
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchool(id, options) {
            return exports.SchoolsApiFp(configuration).getSchool(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of schools
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchools(limit, startingAfter, endingBefore, count, options) {
            return exports.SchoolsApiFp(configuration).getSchools(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the sections for a school
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForSchool(id, limit, startingAfter, endingBefore, options) {
            return exports.SchoolsApiFp(configuration).getSectionsForSchool(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the students for a school
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForSchool(id, limit, startingAfter, endingBefore, options) {
            return exports.SchoolsApiFp(configuration).getStudentsForSchool(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the teachers for a school
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachersForSchool(id, limit, startingAfter, endingBefore, options) {
            return exports.SchoolsApiFp(configuration).getTeachersForSchool(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SchoolsApi - object-oriented interface
 * @export
 * @class SchoolsApi
 * @extends {BaseAPI}
 */
class SchoolsApi extends base_1.BaseAPI {
    /**
     * Returns the district for a school
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolsApi
     */
    getDistrictForSchool(id, options) {
        return exports.SchoolsApiFp(this.configuration).getDistrictForSchool(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a specific school
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolsApi
     */
    getSchool(id, options) {
        return exports.SchoolsApiFp(this.configuration).getSchool(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of schools
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {'' | 'true'} [count]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolsApi
     */
    getSchools(limit, startingAfter, endingBefore, count, options) {
        return exports.SchoolsApiFp(this.configuration).getSchools(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the sections for a school
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolsApi
     */
    getSectionsForSchool(id, limit, startingAfter, endingBefore, options) {
        return exports.SchoolsApiFp(this.configuration).getSectionsForSchool(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the students for a school
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolsApi
     */
    getStudentsForSchool(id, limit, startingAfter, endingBefore, options) {
        return exports.SchoolsApiFp(this.configuration).getStudentsForSchool(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the teachers for a school
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolsApi
     */
    getTeachersForSchool(id, limit, startingAfter, endingBefore, options) {
        return exports.SchoolsApiFp(this.configuration).getTeachersForSchool(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SchoolsApi = SchoolsApi;
/**
 * SectionsApi - axios parameter creator
 * @export
 */
exports.SectionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the course for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseForSection: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getCourseForSection.');
            }
            const localVarPath = `/sections/{id}/course`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the district for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForSection: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getDistrictForSection.');
            }
            const localVarPath = `/sections/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the school for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolForSection: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getSchoolForSection.');
            }
            const localVarPath = `/sections/{id}/school`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSection: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getSection.');
            }
            const localVarPath = `/sections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of sections
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSections: async (limit, startingAfter, endingBefore, count, options = {}) => {
            const localVarPath = `/sections`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the students for a section
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForSection: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getStudentsForSection.');
            }
            const localVarPath = `/sections/{id}/students`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the primary teacher for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeacherForSection: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getTeacherForSection.');
            }
            const localVarPath = `/sections/{id}/teacher`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the teachers for a section
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachersForSection: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getTeachersForSection.');
            }
            const localVarPath = `/sections/{id}/teachers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the term for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTermForSection: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getTermForSection.');
            }
            const localVarPath = `/sections/{id}/term`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SectionsApi - functional programming interface
 * @export
 */
exports.SectionsApiFp = function (configuration) {
    return {
        /**
         * Returns the course for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseForSection(id, options) {
            const localVarAxiosArgs = await exports.SectionsApiAxiosParamCreator(configuration).getCourseForSection(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the district for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForSection(id, options) {
            const localVarAxiosArgs = await exports.SectionsApiAxiosParamCreator(configuration).getDistrictForSection(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the school for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolForSection(id, options) {
            const localVarAxiosArgs = await exports.SectionsApiAxiosParamCreator(configuration).getSchoolForSection(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a specific section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSection(id, options) {
            const localVarAxiosArgs = await exports.SectionsApiAxiosParamCreator(configuration).getSection(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of sections
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSections(limit, startingAfter, endingBefore, count, options) {
            const localVarAxiosArgs = await exports.SectionsApiAxiosParamCreator(configuration).getSections(limit, startingAfter, endingBefore, count, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the students for a section
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudentsForSection(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await exports.SectionsApiAxiosParamCreator(configuration).getStudentsForSection(id, limit, startingAfter, endingBefore, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the primary teacher for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeacherForSection(id, options) {
            const localVarAxiosArgs = await exports.SectionsApiAxiosParamCreator(configuration).getTeacherForSection(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the teachers for a section
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeachersForSection(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await exports.SectionsApiAxiosParamCreator(configuration).getTeachersForSection(id, limit, startingAfter, endingBefore, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the term for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTermForSection(id, options) {
            const localVarAxiosArgs = await exports.SectionsApiAxiosParamCreator(configuration).getTermForSection(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * SectionsApi - factory interface
 * @export
 */
exports.SectionsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Returns the course for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseForSection(id, options) {
            return exports.SectionsApiFp(configuration).getCourseForSection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the district for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForSection(id, options) {
            return exports.SectionsApiFp(configuration).getDistrictForSection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the school for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolForSection(id, options) {
            return exports.SectionsApiFp(configuration).getSchoolForSection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSection(id, options) {
            return exports.SectionsApiFp(configuration).getSection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of sections
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSections(limit, startingAfter, endingBefore, count, options) {
            return exports.SectionsApiFp(configuration).getSections(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the students for a section
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForSection(id, limit, startingAfter, endingBefore, options) {
            return exports.SectionsApiFp(configuration).getStudentsForSection(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the primary teacher for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeacherForSection(id, options) {
            return exports.SectionsApiFp(configuration).getTeacherForSection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the teachers for a section
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachersForSection(id, limit, startingAfter, endingBefore, options) {
            return exports.SectionsApiFp(configuration).getTeachersForSection(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the term for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTermForSection(id, options) {
            return exports.SectionsApiFp(configuration).getTermForSection(id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SectionsApi - object-oriented interface
 * @export
 * @class SectionsApi
 * @extends {BaseAPI}
 */
class SectionsApi extends base_1.BaseAPI {
    /**
     * Returns the course for a section
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    getCourseForSection(id, options) {
        return exports.SectionsApiFp(this.configuration).getCourseForSection(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the district for a section
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    getDistrictForSection(id, options) {
        return exports.SectionsApiFp(this.configuration).getDistrictForSection(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the school for a section
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    getSchoolForSection(id, options) {
        return exports.SectionsApiFp(this.configuration).getSchoolForSection(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a specific section
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    getSection(id, options) {
        return exports.SectionsApiFp(this.configuration).getSection(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of sections
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {'' | 'true'} [count]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    getSections(limit, startingAfter, endingBefore, count, options) {
        return exports.SectionsApiFp(this.configuration).getSections(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the students for a section
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    getStudentsForSection(id, limit, startingAfter, endingBefore, options) {
        return exports.SectionsApiFp(this.configuration).getStudentsForSection(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the primary teacher for a section
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    getTeacherForSection(id, options) {
        return exports.SectionsApiFp(this.configuration).getTeacherForSection(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the teachers for a section
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    getTeachersForSection(id, limit, startingAfter, endingBefore, options) {
        return exports.SectionsApiFp(this.configuration).getTeachersForSection(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the term for a section
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    getTermForSection(id, options) {
        return exports.SectionsApiFp(this.configuration).getTermForSection(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SectionsApi = SectionsApi;
/**
 * StudentsApi - axios parameter creator
 * @export
 */
exports.StudentsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the contacts for a student
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactsForStudent: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getContactsForStudent.');
            }
            const localVarPath = `/students/{id}/contacts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the district for a student
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForStudent: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getDistrictForStudent.');
            }
            const localVarPath = `/students/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the primary school for a student
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolForStudent: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getSchoolForStudent.');
            }
            const localVarPath = `/students/{id}/school`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the schools for a student
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolsForStudent: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getSchoolsForStudent.');
            }
            const localVarPath = `/students/{id}/schools`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the sections for a student
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForStudent: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getSectionsForStudent.');
            }
            const localVarPath = `/students/{id}/sections`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific student
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudent: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getStudent.');
            }
            const localVarPath = `/students/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of students
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudents: async (limit, startingAfter, endingBefore, count, options = {}) => {
            const localVarPath = `/students`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the teachers for a student
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachersForStudent: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getTeachersForStudent.');
            }
            const localVarPath = `/students/{id}/teachers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * StudentsApi - functional programming interface
 * @export
 */
exports.StudentsApiFp = function (configuration) {
    return {
        /**
         * Returns the contacts for a student
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContactsForStudent(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await exports.StudentsApiAxiosParamCreator(configuration).getContactsForStudent(id, limit, startingAfter, endingBefore, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the district for a student
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForStudent(id, options) {
            const localVarAxiosArgs = await exports.StudentsApiAxiosParamCreator(configuration).getDistrictForStudent(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the primary school for a student
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolForStudent(id, options) {
            const localVarAxiosArgs = await exports.StudentsApiAxiosParamCreator(configuration).getSchoolForStudent(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the schools for a student
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolsForStudent(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await exports.StudentsApiAxiosParamCreator(configuration).getSchoolsForStudent(id, limit, startingAfter, endingBefore, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the sections for a student
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSectionsForStudent(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await exports.StudentsApiAxiosParamCreator(configuration).getSectionsForStudent(id, limit, startingAfter, endingBefore, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a specific student
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudent(id, options) {
            const localVarAxiosArgs = await exports.StudentsApiAxiosParamCreator(configuration).getStudent(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of students
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudents(limit, startingAfter, endingBefore, count, options) {
            const localVarAxiosArgs = await exports.StudentsApiAxiosParamCreator(configuration).getStudents(limit, startingAfter, endingBefore, count, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the teachers for a student
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeachersForStudent(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await exports.StudentsApiAxiosParamCreator(configuration).getTeachersForStudent(id, limit, startingAfter, endingBefore, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * StudentsApi - factory interface
 * @export
 */
exports.StudentsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Returns the contacts for a student
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactsForStudent(id, limit, startingAfter, endingBefore, options) {
            return exports.StudentsApiFp(configuration).getContactsForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the district for a student
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForStudent(id, options) {
            return exports.StudentsApiFp(configuration).getDistrictForStudent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the primary school for a student
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolForStudent(id, options) {
            return exports.StudentsApiFp(configuration).getSchoolForStudent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the schools for a student
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolsForStudent(id, limit, startingAfter, endingBefore, options) {
            return exports.StudentsApiFp(configuration).getSchoolsForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the sections for a student
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForStudent(id, limit, startingAfter, endingBefore, options) {
            return exports.StudentsApiFp(configuration).getSectionsForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific student
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudent(id, options) {
            return exports.StudentsApiFp(configuration).getStudent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of students
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudents(limit, startingAfter, endingBefore, count, options) {
            return exports.StudentsApiFp(configuration).getStudents(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the teachers for a student
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachersForStudent(id, limit, startingAfter, endingBefore, options) {
            return exports.StudentsApiFp(configuration).getTeachersForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * StudentsApi - object-oriented interface
 * @export
 * @class StudentsApi
 * @extends {BaseAPI}
 */
class StudentsApi extends base_1.BaseAPI {
    /**
     * Returns the contacts for a student
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    getContactsForStudent(id, limit, startingAfter, endingBefore, options) {
        return exports.StudentsApiFp(this.configuration).getContactsForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the district for a student
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    getDistrictForStudent(id, options) {
        return exports.StudentsApiFp(this.configuration).getDistrictForStudent(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the primary school for a student
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    getSchoolForStudent(id, options) {
        return exports.StudentsApiFp(this.configuration).getSchoolForStudent(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the schools for a student
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    getSchoolsForStudent(id, limit, startingAfter, endingBefore, options) {
        return exports.StudentsApiFp(this.configuration).getSchoolsForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the sections for a student
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    getSectionsForStudent(id, limit, startingAfter, endingBefore, options) {
        return exports.StudentsApiFp(this.configuration).getSectionsForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a specific student
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    getStudent(id, options) {
        return exports.StudentsApiFp(this.configuration).getStudent(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of students
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {'' | 'true'} [count]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    getStudents(limit, startingAfter, endingBefore, count, options) {
        return exports.StudentsApiFp(this.configuration).getStudents(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the teachers for a student
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    getTeachersForStudent(id, limit, startingAfter, endingBefore, options) {
        return exports.StudentsApiFp(this.configuration).getTeachersForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.StudentsApi = StudentsApi;
/**
 * TeachersApi - axios parameter creator
 * @export
 */
exports.TeachersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the district for a teacher
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForTeacher: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getDistrictForTeacher.');
            }
            const localVarPath = `/teachers/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves school info for a teacher.
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolForTeacher: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getSchoolForTeacher.');
            }
            const localVarPath = `/teachers/{id}/school`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the schools for a teacher
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolsForTeacher: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getSchoolsForTeacher.');
            }
            const localVarPath = `/teachers/{id}/schools`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the sections for a teacher
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForTeacher: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getSectionsForTeacher.');
            }
            const localVarPath = `/teachers/{id}/sections`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the students for a teacher
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForTeacher: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getStudentsForTeacher.');
            }
            const localVarPath = `/teachers/{id}/students`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific teacher
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeacher: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getTeacher.');
            }
            const localVarPath = `/teachers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of teachers
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachers: async (limit, startingAfter, endingBefore, count, options = {}) => {
            const localVarPath = `/teachers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TeachersApi - functional programming interface
 * @export
 */
exports.TeachersApiFp = function (configuration) {
    return {
        /**
         * Returns the district for a teacher
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForTeacher(id, options) {
            const localVarAxiosArgs = await exports.TeachersApiAxiosParamCreator(configuration).getDistrictForTeacher(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves school info for a teacher.
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolForTeacher(id, options) {
            const localVarAxiosArgs = await exports.TeachersApiAxiosParamCreator(configuration).getSchoolForTeacher(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the schools for a teacher
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolsForTeacher(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await exports.TeachersApiAxiosParamCreator(configuration).getSchoolsForTeacher(id, limit, startingAfter, endingBefore, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the sections for a teacher
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSectionsForTeacher(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await exports.TeachersApiAxiosParamCreator(configuration).getSectionsForTeacher(id, limit, startingAfter, endingBefore, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the students for a teacher
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudentsForTeacher(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await exports.TeachersApiAxiosParamCreator(configuration).getStudentsForTeacher(id, limit, startingAfter, endingBefore, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a specific teacher
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeacher(id, options) {
            const localVarAxiosArgs = await exports.TeachersApiAxiosParamCreator(configuration).getTeacher(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of teachers
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeachers(limit, startingAfter, endingBefore, count, options) {
            const localVarAxiosArgs = await exports.TeachersApiAxiosParamCreator(configuration).getTeachers(limit, startingAfter, endingBefore, count, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * TeachersApi - factory interface
 * @export
 */
exports.TeachersApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Returns the district for a teacher
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForTeacher(id, options) {
            return exports.TeachersApiFp(configuration).getDistrictForTeacher(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves school info for a teacher.
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolForTeacher(id, options) {
            return exports.TeachersApiFp(configuration).getSchoolForTeacher(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the schools for a teacher
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolsForTeacher(id, limit, startingAfter, endingBefore, options) {
            return exports.TeachersApiFp(configuration).getSchoolsForTeacher(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the sections for a teacher
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForTeacher(id, limit, startingAfter, endingBefore, options) {
            return exports.TeachersApiFp(configuration).getSectionsForTeacher(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the students for a teacher
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForTeacher(id, limit, startingAfter, endingBefore, options) {
            return exports.TeachersApiFp(configuration).getStudentsForTeacher(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific teacher
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeacher(id, options) {
            return exports.TeachersApiFp(configuration).getTeacher(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of teachers
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachers(limit, startingAfter, endingBefore, count, options) {
            return exports.TeachersApiFp(configuration).getTeachers(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TeachersApi - object-oriented interface
 * @export
 * @class TeachersApi
 * @extends {BaseAPI}
 */
class TeachersApi extends base_1.BaseAPI {
    /**
     * Returns the district for a teacher
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    getDistrictForTeacher(id, options) {
        return exports.TeachersApiFp(this.configuration).getDistrictForTeacher(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves school info for a teacher.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    getSchoolForTeacher(id, options) {
        return exports.TeachersApiFp(this.configuration).getSchoolForTeacher(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the schools for a teacher
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    getSchoolsForTeacher(id, limit, startingAfter, endingBefore, options) {
        return exports.TeachersApiFp(this.configuration).getSchoolsForTeacher(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the sections for a teacher
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    getSectionsForTeacher(id, limit, startingAfter, endingBefore, options) {
        return exports.TeachersApiFp(this.configuration).getSectionsForTeacher(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the students for a teacher
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    getStudentsForTeacher(id, limit, startingAfter, endingBefore, options) {
        return exports.TeachersApiFp(this.configuration).getStudentsForTeacher(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a specific teacher
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    getTeacher(id, options) {
        return exports.TeachersApiFp(this.configuration).getTeacher(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of teachers
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {'' | 'true'} [count]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    getTeachers(limit, startingAfter, endingBefore, count, options) {
        return exports.TeachersApiFp(this.configuration).getTeachers(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TeachersApi = TeachersApi;
/**
 * TermsApi - axios parameter creator
 * @export
 */
exports.TermsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the district for a term
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForTerm: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getDistrictForTerm.');
            }
            const localVarPath = `/terms/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the sections for a term
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForTerm: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getSectionsForTerm.');
            }
            const localVarPath = `/terms/{id}/sections`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific term
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerm: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getTerm.');
            }
            const localVarPath = `/terms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of terms
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerms: async (limit, startingAfter, endingBefore, count, options = {}) => {
            const localVarPath = `/terms`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TermsApi - functional programming interface
 * @export
 */
exports.TermsApiFp = function (configuration) {
    return {
        /**
         * Returns the district for a term
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForTerm(id, options) {
            const localVarAxiosArgs = await exports.TermsApiAxiosParamCreator(configuration).getDistrictForTerm(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the sections for a term
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSectionsForTerm(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await exports.TermsApiAxiosParamCreator(configuration).getSectionsForTerm(id, limit, startingAfter, endingBefore, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a specific term
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTerm(id, options) {
            const localVarAxiosArgs = await exports.TermsApiAxiosParamCreator(configuration).getTerm(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of terms
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTerms(limit, startingAfter, endingBefore, count, options) {
            const localVarAxiosArgs = await exports.TermsApiAxiosParamCreator(configuration).getTerms(limit, startingAfter, endingBefore, count, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * TermsApi - factory interface
 * @export
 */
exports.TermsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Returns the district for a term
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForTerm(id, options) {
            return exports.TermsApiFp(configuration).getDistrictForTerm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the sections for a term
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForTerm(id, limit, startingAfter, endingBefore, options) {
            return exports.TermsApiFp(configuration).getSectionsForTerm(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific term
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerm(id, options) {
            return exports.TermsApiFp(configuration).getTerm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of terms
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerms(limit, startingAfter, endingBefore, count, options) {
            return exports.TermsApiFp(configuration).getTerms(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TermsApi - object-oriented interface
 * @export
 * @class TermsApi
 * @extends {BaseAPI}
 */
class TermsApi extends base_1.BaseAPI {
    /**
     * Returns the district for a term
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermsApi
     */
    getDistrictForTerm(id, options) {
        return exports.TermsApiFp(this.configuration).getDistrictForTerm(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the sections for a term
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermsApi
     */
    getSectionsForTerm(id, limit, startingAfter, endingBefore, options) {
        return exports.TermsApiFp(this.configuration).getSectionsForTerm(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a specific term
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermsApi
     */
    getTerm(id, options) {
        return exports.TermsApiFp(this.configuration).getTerm(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of terms
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {'' | 'true'} [count]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermsApi
     */
    getTerms(limit, startingAfter, endingBefore, count, options) {
        return exports.TermsApiFp(this.configuration).getTerms(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TermsApi = TermsApi;
//# sourceMappingURL=api.js.map