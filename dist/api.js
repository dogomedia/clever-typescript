"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Data API
 * Serves the Clever Data API
 *
 * The version of the OpenAPI document: 2.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TermsApi = exports.TermsApiFactory = exports.TermsApiFp = exports.TermsApiAxiosParamCreator = exports.TeachersApi = exports.TeachersApiFactory = exports.TeachersApiFp = exports.TeachersApiAxiosParamCreator = exports.StudentsApi = exports.StudentsApiFactory = exports.StudentsApiFp = exports.StudentsApiAxiosParamCreator = exports.SectionsApi = exports.SectionsApiFactory = exports.SectionsApiFp = exports.SectionsApiAxiosParamCreator = exports.SchoolsApi = exports.SchoolsApiFactory = exports.SchoolsApiFp = exports.SchoolsApiAxiosParamCreator = exports.SchoolAdminsApi = exports.SchoolAdminsApiFactory = exports.SchoolAdminsApiFp = exports.SchoolAdminsApiAxiosParamCreator = exports.EventsApi = exports.EventsApiFactory = exports.EventsApiFp = exports.EventsApiAxiosParamCreator = exports.DistrictsApi = exports.DistrictsApiFactory = exports.DistrictsApiFp = exports.DistrictsApiAxiosParamCreator = exports.DistrictAdminsApi = exports.DistrictAdminsApiFactory = exports.DistrictAdminsApiFp = exports.DistrictAdminsApiAxiosParamCreator = exports.CoursesApi = exports.CoursesApiFactory = exports.CoursesApiFp = exports.CoursesApiAxiosParamCreator = exports.ContactsApi = exports.ContactsApiFactory = exports.ContactsApiFp = exports.ContactsApiAxiosParamCreator = exports.StudentRaceEnum = exports.StudentHomeLanguageEnum = exports.StudentHispanicEthnicityEnum = exports.StudentGradeEnum = exports.StudentGenderEnum = exports.StudentEllStatusEnum = exports.SectionSubjectEnum = exports.SectionGradeEnum = exports.SchoolLowGradeEnum = exports.SchoolHighGradeEnum = exports.LinkRelEnum = exports.DistrictStateEnum = exports.ContactTypeEnum = exports.ContactRelationshipEnum = exports.ContactPhoneTypeEnum = void 0;
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
exports.ContactPhoneTypeEnum = {
    Cell: 'Cell',
    Home: 'Home',
    Work: 'Work',
    Other: 'Other',
    Empty: ''
};
exports.ContactRelationshipEnum = {
    Parent: 'Parent',
    Grandparent: 'Grandparent',
    Self: 'Self',
    AuntUncle: 'Aunt/Uncle',
    Sibling: 'Sibling',
    Other: 'Other',
    Empty: ''
};
exports.ContactTypeEnum = {
    ParentGuardian: 'Parent/Guardian',
    Emergency: 'Emergency',
    Primary: 'Primary',
    Secondary: 'Secondary',
    Family: 'Family',
    Other: 'Other',
    Empty: ''
};
exports.DistrictStateEnum = {
    Running: 'running',
    Pending: 'pending',
    Error: 'error',
    Paused: 'paused',
    Empty: '',
    Success: 'success'
};
exports.LinkRelEnum = {
    Next: 'next',
    Prev: 'prev',
    Self: 'self'
};
exports.SchoolHighGradeEnum = {
    InfantToddler: 'InfantToddler',
    Preschool: 'Preschool',
    PreKindergarten: 'PreKindergarten',
    TransitionalKindergarten: 'TransitionalKindergarten',
    Kindergarten: 'Kindergarten',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _13: '13',
    PostGraduate: 'PostGraduate',
    Ungraded: 'Ungraded',
    Other: 'Other',
    Empty: ''
};
exports.SchoolLowGradeEnum = {
    InfantToddler: 'InfantToddler',
    Preschool: 'Preschool',
    PreKindergarten: 'PreKindergarten',
    TransitionalKindergarten: 'TransitionalKindergarten',
    Kindergarten: 'Kindergarten',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _13: '13',
    PostGraduate: 'PostGraduate',
    Ungraded: 'Ungraded',
    Other: 'Other',
    Empty: ''
};
exports.SectionGradeEnum = {
    InfantToddler: 'InfantToddler',
    Preschool: 'Preschool',
    PreKindergarten: 'PreKindergarten',
    TransitionalKindergarten: 'TransitionalKindergarten',
    Kindergarten: 'Kindergarten',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _13: '13',
    PostGraduate: 'PostGraduate',
    Ungraded: 'Ungraded',
    Other: 'Other',
    Empty: ''
};
exports.SectionSubjectEnum = {
    EnglishLanguageArts: 'english/language arts',
    Math: 'math',
    Science: 'science',
    SocialStudies: 'social studies',
    Language: 'language',
    HomeroomAdvisory: 'homeroom/advisory',
    InterventionsOnlineLearning: 'interventions/online learning',
    TechnologyAndEngineering: 'technology and engineering',
    PeAndHealth: 'PE and health',
    ArtsAndMusic: 'arts and music',
    Other: 'other',
    Empty: ''
};
exports.StudentEllStatusEnum = {
    Y: 'Y',
    N: 'N',
    Empty: ''
};
exports.StudentGenderEnum = {
    M: 'M',
    F: 'F',
    X: 'X',
    Empty: ''
};
exports.StudentGradeEnum = {
    InfantToddler: 'InfantToddler',
    Preschool: 'Preschool',
    PreKindergarten: 'PreKindergarten',
    TransitionalKindergarten: 'TransitionalKindergarten',
    Kindergarten: 'Kindergarten',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _13: '13',
    PostGraduate: 'PostGraduate',
    Ungraded: 'Ungraded',
    Other: 'Other',
    Empty: ''
};
exports.StudentHispanicEthnicityEnum = {
    Y: 'Y',
    N: 'N',
    Empty: ''
};
exports.StudentHomeLanguageEnum = {
    English: 'English',
    Albanian: 'Albanian',
    Amharic: 'Amharic',
    Arabic: 'Arabic',
    Bengali: 'Bengali',
    Bosnian: 'Bosnian',
    Burmese: 'Burmese',
    Cantonese: 'Cantonese',
    Chinese: 'Chinese',
    Dutch: 'Dutch',
    Farsi: 'Farsi',
    French: 'French',
    German: 'German',
    Hebrew: 'Hebrew',
    Hindi: 'Hindi',
    Hmong: 'Hmong',
    Ilocano: 'Ilocano',
    Japanese: 'Japanese',
    Javanese: 'Javanese',
    Karen: 'Karen',
    Khmer: 'Khmer',
    Korean: 'Korean',
    Laotian: 'Laotian',
    Latvian: 'Latvian',
    Malay: 'Malay',
    Mandarin: 'Mandarin',
    Nepali: 'Nepali',
    Oromo: 'Oromo',
    Polish: 'Polish',
    Portuguese: 'Portuguese',
    Punjabi: 'Punjabi',
    Romanian: 'Romanian',
    Russian: 'Russian',
    Samoan: 'Samoan',
    Serbian: 'Serbian',
    Somali: 'Somali',
    Spanish: 'Spanish',
    Swahili: 'Swahili',
    Tagalog: 'Tagalog',
    Tamil: 'Tamil',
    Telugu: 'Telugu',
    Thai: 'Thai',
    Tigrinya: 'Tigrinya',
    Turkish: 'Turkish',
    Ukrainian: 'Ukrainian',
    Urdu: 'Urdu',
    Vietnamese: 'Vietnamese',
    Empty: ''
};
exports.StudentRaceEnum = {
    Caucasian: 'Caucasian',
    Asian: 'Asian',
    BlackOrAfricanAmerican: 'Black or African American',
    AmericanIndian: 'American Indian',
    HawaiianOrOtherPacificIslander: 'Hawaiian or Other Pacific Islander',
    TwoOrMoreRaces: 'Two or More Races',
    Unknown: 'Unknown',
    Empty: ''
};
/**
 * ContactsApi - axios parameter creator
 * @export
 */
exports.ContactsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a specific student contact
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContact: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getContact', 'id', id);
            const localVarPath = `/contacts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of student contacts
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContacts: async (limit, startingAfter, endingBefore, count, options = {}) => {
            const localVarPath = `/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the district for a student contact
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForContact: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getDistrictForContact', 'id', id);
            const localVarPath = `/contacts/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the students for a student contact
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForContact: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getStudentsForContact', 'id', id);
            const localVarPath = `/contacts/{id}/students`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ContactsApi - functional programming interface
 * @export
 */
exports.ContactsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ContactsApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns a specific student contact
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContact(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContact(id, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns a list of student contacts
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContacts(limit, startingAfter, endingBefore, count, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContacts(limit, startingAfter, endingBefore, count, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns the district for a student contact
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForContact(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistrictForContact(id, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns the students for a student contact
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudentsForContact(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudentsForContact(id, limit, startingAfter, endingBefore, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
/**
 * ContactsApi - factory interface
 * @export
 */
exports.ContactsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ContactsApiFp(configuration);
    return {
        /**
         * Returns a specific student contact
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContact(id, options) {
            return localVarFp.getContact(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of student contacts
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContacts(limit, startingAfter, endingBefore, count, options) {
            return localVarFp.getContacts(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the district for a student contact
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForContact(id, options) {
            return localVarFp.getDistrictForContact(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the students for a student contact
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForContact(id, limit, startingAfter, endingBefore, options) {
            return localVarFp.getStudentsForContact(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ContactsApi - object-oriented interface
 * @export
 * @class ContactsApi
 * @extends {BaseAPI}
 */
class ContactsApi extends base_1.BaseAPI {
    /**
     * Returns a specific student contact
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    getContact(id, options) {
        return exports.ContactsApiFp(this.configuration).getContact(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of student contacts
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {'' | 'true' | 'false' | 'undefined'} [count]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    getContacts(limit, startingAfter, endingBefore, count, options) {
        return exports.ContactsApiFp(this.configuration).getContacts(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the district for a student contact
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    getDistrictForContact(id, options) {
        return exports.ContactsApiFp(this.configuration).getDistrictForContact(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the students for a student contact
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    getStudentsForContact(id, limit, startingAfter, endingBefore, options) {
        return exports.ContactsApiFp(this.configuration).getStudentsForContact(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ContactsApi = ContactsApi;
/**
 * CoursesApi - axios parameter creator
 * @export
 */
exports.CoursesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a specific course
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourse: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getCourse', 'id', id);
            const localVarPath = `/courses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of courses
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourses: async (limit, startingAfter, endingBefore, count, options = {}) => {
            const localVarPath = `/courses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the district for a course
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForCourse: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getDistrictForCourse', 'id', id);
            const localVarPath = `/courses/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the sections for a Courses
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForCourse: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getSectionsForCourse', 'id', id);
            const localVarPath = `/courses/{id}/sections`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CoursesApi - functional programming interface
 * @export
 */
exports.CoursesApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.CoursesApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns a specific course
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourse(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourse(id, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns a list of courses
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourses(limit, startingAfter, endingBefore, count, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourses(limit, startingAfter, endingBefore, count, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns the district for a course
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForCourse(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistrictForCourse(id, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns the sections for a Courses
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSectionsForCourse(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSectionsForCourse(id, limit, startingAfter, endingBefore, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
/**
 * CoursesApi - factory interface
 * @export
 */
exports.CoursesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.CoursesApiFp(configuration);
    return {
        /**
         * Returns a specific course
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourse(id, options) {
            return localVarFp.getCourse(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of courses
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourses(limit, startingAfter, endingBefore, count, options) {
            return localVarFp.getCourses(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the district for a course
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForCourse(id, options) {
            return localVarFp.getDistrictForCourse(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the sections for a Courses
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForCourse(id, limit, startingAfter, endingBefore, options) {
            return localVarFp.getSectionsForCourse(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CoursesApi - object-oriented interface
 * @export
 * @class CoursesApi
 * @extends {BaseAPI}
 */
class CoursesApi extends base_1.BaseAPI {
    /**
     * Returns a specific course
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    getCourse(id, options) {
        return exports.CoursesApiFp(this.configuration).getCourse(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of courses
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {'' | 'true' | 'false' | 'undefined'} [count]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    getCourses(limit, startingAfter, endingBefore, count, options) {
        return exports.CoursesApiFp(this.configuration).getCourses(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the district for a course
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    getDistrictForCourse(id, options) {
        return exports.CoursesApiFp(this.configuration).getDistrictForCourse(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the sections for a Courses
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    getSectionsForCourse(id, limit, startingAfter, endingBefore, options) {
        return exports.CoursesApiFp(this.configuration).getSectionsForCourse(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CoursesApi = CoursesApi;
/**
 * DistrictAdminsApi - axios parameter creator
 * @export
 */
exports.DistrictAdminsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a specific district admin
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictAdmin: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getDistrictAdmin', 'id', id);
            const localVarPath = `/district_admins/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of district admins
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictAdmins: async (limit, startingAfter, endingBefore, count, options = {}) => {
            const localVarPath = `/district_admins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the district for a district admin
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForDistrictAdmin: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getDistrictForDistrictAdmin', 'id', id);
            const localVarPath = `/district_admins/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * DistrictAdminsApi - functional programming interface
 * @export
 */
exports.DistrictAdminsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.DistrictAdminsApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns a specific district admin
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictAdmin(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistrictAdmin(id, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns a list of district admins
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictAdmins(limit, startingAfter, endingBefore, count, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistrictAdmins(limit, startingAfter, endingBefore, count, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns the district for a district admin
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForDistrictAdmin(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistrictForDistrictAdmin(id, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
/**
 * DistrictAdminsApi - factory interface
 * @export
 */
exports.DistrictAdminsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.DistrictAdminsApiFp(configuration);
    return {
        /**
         * Returns a specific district admin
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictAdmin(id, options) {
            return localVarFp.getDistrictAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of district admins
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictAdmins(limit, startingAfter, endingBefore, count, options) {
            return localVarFp.getDistrictAdmins(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the district for a district admin
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForDistrictAdmin(id, options) {
            return localVarFp.getDistrictForDistrictAdmin(id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DistrictAdminsApi - object-oriented interface
 * @export
 * @class DistrictAdminsApi
 * @extends {BaseAPI}
 */
class DistrictAdminsApi extends base_1.BaseAPI {
    /**
     * Returns a specific district admin
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictAdminsApi
     */
    getDistrictAdmin(id, options) {
        return exports.DistrictAdminsApiFp(this.configuration).getDistrictAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of district admins
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {'' | 'true' | 'false' | 'undefined'} [count]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictAdminsApi
     */
    getDistrictAdmins(limit, startingAfter, endingBefore, count, options) {
        return exports.DistrictAdminsApiFp(this.configuration).getDistrictAdmins(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the district for a district admin
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictAdminsApi
     */
    getDistrictForDistrictAdmin(id, options) {
        return exports.DistrictAdminsApiFp(this.configuration).getDistrictForDistrictAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.DistrictAdminsApi = DistrictAdminsApi;
/**
 * DistrictsApi - axios parameter creator
 * @export
 */
exports.DistrictsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a specific district
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrict: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getDistrict', 'id', id);
            const localVarPath = `/districts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of districts. In practice this will only return the one district associated with the bearer token
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistricts: async (count, options = {}) => {
            const localVarPath = `/districts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * DistrictsApi - functional programming interface
 * @export
 */
exports.DistrictsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.DistrictsApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns a specific district
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrict(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistrict(id, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns a list of districts. In practice this will only return the one district associated with the bearer token
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistricts(count, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistricts(count, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
/**
 * DistrictsApi - factory interface
 * @export
 */
exports.DistrictsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.DistrictsApiFp(configuration);
    return {
        /**
         * Returns a specific district
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrict(id, options) {
            return localVarFp.getDistrict(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of districts. In practice this will only return the one district associated with the bearer token
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistricts(count, options) {
            return localVarFp.getDistricts(count, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DistrictsApi - object-oriented interface
 * @export
 * @class DistrictsApi
 * @extends {BaseAPI}
 */
class DistrictsApi extends base_1.BaseAPI {
    /**
     * Returns a specific district
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictsApi
     */
    getDistrict(id, options) {
        return exports.DistrictsApiFp(this.configuration).getDistrict(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of districts. In practice this will only return the one district associated with the bearer token
     * @param {'' | 'true' | 'false' | 'undefined'} [count]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictsApi
     */
    getDistricts(count, options) {
        return exports.DistrictsApiFp(this.configuration).getDistricts(count, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.DistrictsApi = DistrictsApi;
/**
 * EventsApi - axios parameter creator
 * @export
 */
exports.EventsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the specific event
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getEvent', 'id', id);
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of events
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {string} [school]
         * @param {Array<string>} [recordType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (limit, startingAfter, endingBefore, school, recordType, options = {}) => {
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            if (school !== undefined) {
                localVarQueryParameter['school'] = school;
            }
            if (recordType) {
                localVarQueryParameter['record_type'] = recordType;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * EventsApi - functional programming interface
 * @export
 */
exports.EventsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.EventsApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns the specific event
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvent(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvent(id, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns a list of events
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {string} [school]
         * @param {Array<string>} [recordType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(limit, startingAfter, endingBefore, school, recordType, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(limit, startingAfter, endingBefore, school, recordType, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
/**
 * EventsApi - factory interface
 * @export
 */
exports.EventsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.EventsApiFp(configuration);
    return {
        /**
         * Returns the specific event
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(id, options) {
            return localVarFp.getEvent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of events
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {string} [school]
         * @param {Array<string>} [recordType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(limit, startingAfter, endingBefore, school, recordType, options) {
            return localVarFp.getEvents(limit, startingAfter, endingBefore, school, recordType, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
class EventsApi extends base_1.BaseAPI {
    /**
     * Returns the specific event
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    getEvent(id, options) {
        return exports.EventsApiFp(this.configuration).getEvent(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of events
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {string} [school]
     * @param {Array<string>} [recordType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    getEvents(limit, startingAfter, endingBefore, school, recordType, options) {
        return exports.EventsApiFp(this.configuration).getEvents(limit, startingAfter, endingBefore, school, recordType, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.EventsApi = EventsApi;
/**
 * SchoolAdminsApi - axios parameter creator
 * @export
 */
exports.SchoolAdminsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the district for a school admin
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForSchoolAdmin: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getDistrictForSchoolAdmin', 'id', id);
            const localVarPath = `/school_admins/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific school admin
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolAdmin: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getSchoolAdmin', 'id', id);
            const localVarPath = `/school_admins/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of school admins
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolAdmins: async (limit, startingAfter, endingBefore, count, options = {}) => {
            const localVarPath = `/school_admins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the schools for a school admin
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolsForSchoolAdmin: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getSchoolsForSchoolAdmin', 'id', id);
            const localVarPath = `/school_admins/{id}/schools`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SchoolAdminsApi - functional programming interface
 * @export
 */
exports.SchoolAdminsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.SchoolAdminsApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns the district for a school admin
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForSchoolAdmin(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistrictForSchoolAdmin(id, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns a specific school admin
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolAdmin(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchoolAdmin(id, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns a list of school admins
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolAdmins(limit, startingAfter, endingBefore, count, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchoolAdmins(limit, startingAfter, endingBefore, count, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns the schools for a school admin
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolsForSchoolAdmin(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchoolsForSchoolAdmin(id, limit, startingAfter, endingBefore, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
/**
 * SchoolAdminsApi - factory interface
 * @export
 */
exports.SchoolAdminsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.SchoolAdminsApiFp(configuration);
    return {
        /**
         * Returns the district for a school admin
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForSchoolAdmin(id, options) {
            return localVarFp.getDistrictForSchoolAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific school admin
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolAdmin(id, options) {
            return localVarFp.getSchoolAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of school admins
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolAdmins(limit, startingAfter, endingBefore, count, options) {
            return localVarFp.getSchoolAdmins(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the schools for a school admin
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolsForSchoolAdmin(id, limit, startingAfter, endingBefore, options) {
            return localVarFp.getSchoolsForSchoolAdmin(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SchoolAdminsApi - object-oriented interface
 * @export
 * @class SchoolAdminsApi
 * @extends {BaseAPI}
 */
class SchoolAdminsApi extends base_1.BaseAPI {
    /**
     * Returns the district for a school admin
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolAdminsApi
     */
    getDistrictForSchoolAdmin(id, options) {
        return exports.SchoolAdminsApiFp(this.configuration).getDistrictForSchoolAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a specific school admin
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolAdminsApi
     */
    getSchoolAdmin(id, options) {
        return exports.SchoolAdminsApiFp(this.configuration).getSchoolAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of school admins
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {'' | 'true' | 'false' | 'undefined'} [count]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolAdminsApi
     */
    getSchoolAdmins(limit, startingAfter, endingBefore, count, options) {
        return exports.SchoolAdminsApiFp(this.configuration).getSchoolAdmins(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the schools for a school admin
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolAdminsApi
     */
    getSchoolsForSchoolAdmin(id, limit, startingAfter, endingBefore, options) {
        return exports.SchoolAdminsApiFp(this.configuration).getSchoolsForSchoolAdmin(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SchoolAdminsApi = SchoolAdminsApi;
/**
 * SchoolsApi - axios parameter creator
 * @export
 */
exports.SchoolsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the district for a school
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForSchool: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getDistrictForSchool', 'id', id);
            const localVarPath = `/schools/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific school
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchool: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getSchool', 'id', id);
            const localVarPath = `/schools/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of schools
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchools: async (limit, startingAfter, endingBefore, count, options = {}) => {
            const localVarPath = `/schools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the sections for a school
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForSchool: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getSectionsForSchool', 'id', id);
            const localVarPath = `/schools/{id}/sections`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the students for a school
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForSchool: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getStudentsForSchool', 'id', id);
            const localVarPath = `/schools/{id}/students`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the teachers for a school
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachersForSchool: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getTeachersForSchool', 'id', id);
            const localVarPath = `/schools/{id}/teachers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SchoolsApi - functional programming interface
 * @export
 */
exports.SchoolsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.SchoolsApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns the district for a school
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForSchool(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistrictForSchool(id, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns a specific school
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchool(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchool(id, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns a list of schools
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchools(limit, startingAfter, endingBefore, count, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchools(limit, startingAfter, endingBefore, count, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns the sections for a school
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSectionsForSchool(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSectionsForSchool(id, limit, startingAfter, endingBefore, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns the students for a school
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudentsForSchool(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudentsForSchool(id, limit, startingAfter, endingBefore, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns the teachers for a school
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeachersForSchool(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeachersForSchool(id, limit, startingAfter, endingBefore, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
/**
 * SchoolsApi - factory interface
 * @export
 */
exports.SchoolsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.SchoolsApiFp(configuration);
    return {
        /**
         * Returns the district for a school
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForSchool(id, options) {
            return localVarFp.getDistrictForSchool(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific school
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchool(id, options) {
            return localVarFp.getSchool(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of schools
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchools(limit, startingAfter, endingBefore, count, options) {
            return localVarFp.getSchools(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the sections for a school
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForSchool(id, limit, startingAfter, endingBefore, options) {
            return localVarFp.getSectionsForSchool(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the students for a school
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForSchool(id, limit, startingAfter, endingBefore, options) {
            return localVarFp.getStudentsForSchool(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the teachers for a school
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachersForSchool(id, limit, startingAfter, endingBefore, options) {
            return localVarFp.getTeachersForSchool(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SchoolsApi - object-oriented interface
 * @export
 * @class SchoolsApi
 * @extends {BaseAPI}
 */
class SchoolsApi extends base_1.BaseAPI {
    /**
     * Returns the district for a school
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolsApi
     */
    getDistrictForSchool(id, options) {
        return exports.SchoolsApiFp(this.configuration).getDistrictForSchool(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a specific school
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolsApi
     */
    getSchool(id, options) {
        return exports.SchoolsApiFp(this.configuration).getSchool(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of schools
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {'' | 'true' | 'false' | 'undefined'} [count]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolsApi
     */
    getSchools(limit, startingAfter, endingBefore, count, options) {
        return exports.SchoolsApiFp(this.configuration).getSchools(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the sections for a school
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolsApi
     */
    getSectionsForSchool(id, limit, startingAfter, endingBefore, options) {
        return exports.SchoolsApiFp(this.configuration).getSectionsForSchool(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the students for a school
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolsApi
     */
    getStudentsForSchool(id, limit, startingAfter, endingBefore, options) {
        return exports.SchoolsApiFp(this.configuration).getStudentsForSchool(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the teachers for a school
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolsApi
     */
    getTeachersForSchool(id, limit, startingAfter, endingBefore, options) {
        return exports.SchoolsApiFp(this.configuration).getTeachersForSchool(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SchoolsApi = SchoolsApi;
/**
 * SectionsApi - axios parameter creator
 * @export
 */
exports.SectionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the course for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseForSection: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getCourseForSection', 'id', id);
            const localVarPath = `/sections/{id}/course`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the district for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForSection: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getDistrictForSection', 'id', id);
            const localVarPath = `/sections/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the school for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolForSection: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getSchoolForSection', 'id', id);
            const localVarPath = `/sections/{id}/school`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSection: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getSection', 'id', id);
            const localVarPath = `/sections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of sections
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSections: async (limit, startingAfter, endingBefore, count, options = {}) => {
            const localVarPath = `/sections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the students for a section
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForSection: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getStudentsForSection', 'id', id);
            const localVarPath = `/sections/{id}/students`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the primary teacher for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeacherForSection: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getTeacherForSection', 'id', id);
            const localVarPath = `/sections/{id}/teacher`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the teachers for a section
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachersForSection: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getTeachersForSection', 'id', id);
            const localVarPath = `/sections/{id}/teachers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the term for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTermForSection: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getTermForSection', 'id', id);
            const localVarPath = `/sections/{id}/term`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SectionsApi - functional programming interface
 * @export
 */
exports.SectionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.SectionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns the course for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseForSection(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseForSection(id, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns the district for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForSection(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistrictForSection(id, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns the school for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolForSection(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchoolForSection(id, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns a specific section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSection(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSection(id, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns a list of sections
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSections(limit, startingAfter, endingBefore, count, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSections(limit, startingAfter, endingBefore, count, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns the students for a section
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudentsForSection(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudentsForSection(id, limit, startingAfter, endingBefore, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns the primary teacher for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeacherForSection(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeacherForSection(id, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns the teachers for a section
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeachersForSection(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeachersForSection(id, limit, startingAfter, endingBefore, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns the term for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTermForSection(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTermForSection(id, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
/**
 * SectionsApi - factory interface
 * @export
 */
exports.SectionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.SectionsApiFp(configuration);
    return {
        /**
         * Returns the course for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseForSection(id, options) {
            return localVarFp.getCourseForSection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the district for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForSection(id, options) {
            return localVarFp.getDistrictForSection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the school for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolForSection(id, options) {
            return localVarFp.getSchoolForSection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSection(id, options) {
            return localVarFp.getSection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of sections
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSections(limit, startingAfter, endingBefore, count, options) {
            return localVarFp.getSections(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the students for a section
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForSection(id, limit, startingAfter, endingBefore, options) {
            return localVarFp.getStudentsForSection(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the primary teacher for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeacherForSection(id, options) {
            return localVarFp.getTeacherForSection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the teachers for a section
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachersForSection(id, limit, startingAfter, endingBefore, options) {
            return localVarFp.getTeachersForSection(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the term for a section
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTermForSection(id, options) {
            return localVarFp.getTermForSection(id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SectionsApi - object-oriented interface
 * @export
 * @class SectionsApi
 * @extends {BaseAPI}
 */
class SectionsApi extends base_1.BaseAPI {
    /**
     * Returns the course for a section
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    getCourseForSection(id, options) {
        return exports.SectionsApiFp(this.configuration).getCourseForSection(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the district for a section
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    getDistrictForSection(id, options) {
        return exports.SectionsApiFp(this.configuration).getDistrictForSection(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the school for a section
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    getSchoolForSection(id, options) {
        return exports.SectionsApiFp(this.configuration).getSchoolForSection(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a specific section
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    getSection(id, options) {
        return exports.SectionsApiFp(this.configuration).getSection(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of sections
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {'' | 'true' | 'false' | 'undefined'} [count]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    getSections(limit, startingAfter, endingBefore, count, options) {
        return exports.SectionsApiFp(this.configuration).getSections(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the students for a section
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    getStudentsForSection(id, limit, startingAfter, endingBefore, options) {
        return exports.SectionsApiFp(this.configuration).getStudentsForSection(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the primary teacher for a section
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    getTeacherForSection(id, options) {
        return exports.SectionsApiFp(this.configuration).getTeacherForSection(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the teachers for a section
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    getTeachersForSection(id, limit, startingAfter, endingBefore, options) {
        return exports.SectionsApiFp(this.configuration).getTeachersForSection(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the term for a section
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    getTermForSection(id, options) {
        return exports.SectionsApiFp(this.configuration).getTermForSection(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SectionsApi = SectionsApi;
/**
 * StudentsApi - axios parameter creator
 * @export
 */
exports.StudentsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the contacts for a student
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactsForStudent: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getContactsForStudent', 'id', id);
            const localVarPath = `/students/{id}/contacts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the district for a student
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForStudent: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getDistrictForStudent', 'id', id);
            const localVarPath = `/students/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the primary school for a student
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolForStudent: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getSchoolForStudent', 'id', id);
            const localVarPath = `/students/{id}/school`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the schools for a student
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolsForStudent: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getSchoolsForStudent', 'id', id);
            const localVarPath = `/students/{id}/schools`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the sections for a student
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForStudent: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getSectionsForStudent', 'id', id);
            const localVarPath = `/students/{id}/sections`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific student
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudent: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getStudent', 'id', id);
            const localVarPath = `/students/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of students
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudents: async (limit, startingAfter, endingBefore, count, options = {}) => {
            const localVarPath = `/students`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the teachers for a student
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachersForStudent: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getTeachersForStudent', 'id', id);
            const localVarPath = `/students/{id}/teachers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * StudentsApi - functional programming interface
 * @export
 */
exports.StudentsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.StudentsApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns the contacts for a student
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContactsForStudent(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContactsForStudent(id, limit, startingAfter, endingBefore, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns the district for a student
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForStudent(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistrictForStudent(id, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns the primary school for a student
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolForStudent(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchoolForStudent(id, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns the schools for a student
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolsForStudent(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchoolsForStudent(id, limit, startingAfter, endingBefore, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns the sections for a student
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSectionsForStudent(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSectionsForStudent(id, limit, startingAfter, endingBefore, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns a specific student
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudent(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudent(id, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns a list of students
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudents(limit, startingAfter, endingBefore, count, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudents(limit, startingAfter, endingBefore, count, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns the teachers for a student
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeachersForStudent(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeachersForStudent(id, limit, startingAfter, endingBefore, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
/**
 * StudentsApi - factory interface
 * @export
 */
exports.StudentsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.StudentsApiFp(configuration);
    return {
        /**
         * Returns the contacts for a student
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactsForStudent(id, limit, startingAfter, endingBefore, options) {
            return localVarFp.getContactsForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the district for a student
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForStudent(id, options) {
            return localVarFp.getDistrictForStudent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the primary school for a student
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolForStudent(id, options) {
            return localVarFp.getSchoolForStudent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the schools for a student
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolsForStudent(id, limit, startingAfter, endingBefore, options) {
            return localVarFp.getSchoolsForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the sections for a student
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForStudent(id, limit, startingAfter, endingBefore, options) {
            return localVarFp.getSectionsForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific student
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudent(id, options) {
            return localVarFp.getStudent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of students
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudents(limit, startingAfter, endingBefore, count, options) {
            return localVarFp.getStudents(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the teachers for a student
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachersForStudent(id, limit, startingAfter, endingBefore, options) {
            return localVarFp.getTeachersForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * StudentsApi - object-oriented interface
 * @export
 * @class StudentsApi
 * @extends {BaseAPI}
 */
class StudentsApi extends base_1.BaseAPI {
    /**
     * Returns the contacts for a student
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    getContactsForStudent(id, limit, startingAfter, endingBefore, options) {
        return exports.StudentsApiFp(this.configuration).getContactsForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the district for a student
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    getDistrictForStudent(id, options) {
        return exports.StudentsApiFp(this.configuration).getDistrictForStudent(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the primary school for a student
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    getSchoolForStudent(id, options) {
        return exports.StudentsApiFp(this.configuration).getSchoolForStudent(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the schools for a student
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    getSchoolsForStudent(id, limit, startingAfter, endingBefore, options) {
        return exports.StudentsApiFp(this.configuration).getSchoolsForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the sections for a student
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    getSectionsForStudent(id, limit, startingAfter, endingBefore, options) {
        return exports.StudentsApiFp(this.configuration).getSectionsForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a specific student
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    getStudent(id, options) {
        return exports.StudentsApiFp(this.configuration).getStudent(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of students
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {'' | 'true' | 'false' | 'undefined'} [count]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    getStudents(limit, startingAfter, endingBefore, count, options) {
        return exports.StudentsApiFp(this.configuration).getStudents(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the teachers for a student
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    getTeachersForStudent(id, limit, startingAfter, endingBefore, options) {
        return exports.StudentsApiFp(this.configuration).getTeachersForStudent(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.StudentsApi = StudentsApi;
/**
 * TeachersApi - axios parameter creator
 * @export
 */
exports.TeachersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the district for a teacher
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForTeacher: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getDistrictForTeacher', 'id', id);
            const localVarPath = `/teachers/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves school info for a teacher.
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolForTeacher: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getSchoolForTeacher', 'id', id);
            const localVarPath = `/teachers/{id}/school`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the schools for a teacher
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolsForTeacher: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getSchoolsForTeacher', 'id', id);
            const localVarPath = `/teachers/{id}/schools`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the sections for a teacher
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForTeacher: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getSectionsForTeacher', 'id', id);
            const localVarPath = `/teachers/{id}/sections`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the students for a teacher
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForTeacher: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getStudentsForTeacher', 'id', id);
            const localVarPath = `/teachers/{id}/students`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific teacher
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeacher: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getTeacher', 'id', id);
            const localVarPath = `/teachers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of teachers
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachers: async (limit, startingAfter, endingBefore, count, options = {}) => {
            const localVarPath = `/teachers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TeachersApi - functional programming interface
 * @export
 */
exports.TeachersApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.TeachersApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns the district for a teacher
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForTeacher(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistrictForTeacher(id, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves school info for a teacher.
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolForTeacher(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchoolForTeacher(id, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns the schools for a teacher
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolsForTeacher(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchoolsForTeacher(id, limit, startingAfter, endingBefore, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns the sections for a teacher
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSectionsForTeacher(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSectionsForTeacher(id, limit, startingAfter, endingBefore, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns the students for a teacher
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudentsForTeacher(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudentsForTeacher(id, limit, startingAfter, endingBefore, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns a specific teacher
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeacher(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeacher(id, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns a list of teachers
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeachers(limit, startingAfter, endingBefore, count, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeachers(limit, startingAfter, endingBefore, count, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
/**
 * TeachersApi - factory interface
 * @export
 */
exports.TeachersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.TeachersApiFp(configuration);
    return {
        /**
         * Returns the district for a teacher
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForTeacher(id, options) {
            return localVarFp.getDistrictForTeacher(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves school info for a teacher.
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolForTeacher(id, options) {
            return localVarFp.getSchoolForTeacher(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the schools for a teacher
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolsForTeacher(id, limit, startingAfter, endingBefore, options) {
            return localVarFp.getSchoolsForTeacher(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the sections for a teacher
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForTeacher(id, limit, startingAfter, endingBefore, options) {
            return localVarFp.getSectionsForTeacher(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the students for a teacher
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsForTeacher(id, limit, startingAfter, endingBefore, options) {
            return localVarFp.getStudentsForTeacher(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific teacher
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeacher(id, options) {
            return localVarFp.getTeacher(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of teachers
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachers(limit, startingAfter, endingBefore, count, options) {
            return localVarFp.getTeachers(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TeachersApi - object-oriented interface
 * @export
 * @class TeachersApi
 * @extends {BaseAPI}
 */
class TeachersApi extends base_1.BaseAPI {
    /**
     * Returns the district for a teacher
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    getDistrictForTeacher(id, options) {
        return exports.TeachersApiFp(this.configuration).getDistrictForTeacher(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves school info for a teacher.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    getSchoolForTeacher(id, options) {
        return exports.TeachersApiFp(this.configuration).getSchoolForTeacher(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the schools for a teacher
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    getSchoolsForTeacher(id, limit, startingAfter, endingBefore, options) {
        return exports.TeachersApiFp(this.configuration).getSchoolsForTeacher(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the sections for a teacher
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    getSectionsForTeacher(id, limit, startingAfter, endingBefore, options) {
        return exports.TeachersApiFp(this.configuration).getSectionsForTeacher(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the students for a teacher
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    getStudentsForTeacher(id, limit, startingAfter, endingBefore, options) {
        return exports.TeachersApiFp(this.configuration).getStudentsForTeacher(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a specific teacher
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    getTeacher(id, options) {
        return exports.TeachersApiFp(this.configuration).getTeacher(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of teachers
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {'' | 'true' | 'false' | 'undefined'} [count]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    getTeachers(limit, startingAfter, endingBefore, count, options) {
        return exports.TeachersApiFp(this.configuration).getTeachers(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TeachersApi = TeachersApi;
/**
 * TermsApi - axios parameter creator
 * @export
 */
exports.TermsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the district for a term
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForTerm: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getDistrictForTerm', 'id', id);
            const localVarPath = `/terms/{id}/district`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the sections for a term
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForTerm: async (id, limit, startingAfter, endingBefore, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getSectionsForTerm', 'id', id);
            const localVarPath = `/terms/{id}/sections`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific term
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerm: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getTerm', 'id', id);
            const localVarPath = `/terms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of terms
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerms: async (limit, startingAfter, endingBefore, count, options = {}) => {
            const localVarPath = `/terms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oauth required
            // oauth required
            await common_1.setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TermsApi - functional programming interface
 * @export
 */
exports.TermsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.TermsApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns the district for a term
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistrictForTerm(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistrictForTerm(id, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns the sections for a term
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSectionsForTerm(id, limit, startingAfter, endingBefore, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSectionsForTerm(id, limit, startingAfter, endingBefore, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns a specific term
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTerm(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTerm(id, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns a list of terms
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTerms(limit, startingAfter, endingBefore, count, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTerms(limit, startingAfter, endingBefore, count, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
/**
 * TermsApi - factory interface
 * @export
 */
exports.TermsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.TermsApiFp(configuration);
    return {
        /**
         * Returns the district for a term
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictForTerm(id, options) {
            return localVarFp.getDistrictForTerm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the sections for a term
         * @param {string} id
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsForTerm(id, limit, startingAfter, endingBefore, options) {
            return localVarFp.getSectionsForTerm(id, limit, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific term
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerm(id, options) {
            return localVarFp.getTerm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of terms
         * @param {number} [limit]
         * @param {string} [startingAfter]
         * @param {string} [endingBefore]
         * @param {'' | 'true' | 'false' | 'undefined'} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerms(limit, startingAfter, endingBefore, count, options) {
            return localVarFp.getTerms(limit, startingAfter, endingBefore, count, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TermsApi - object-oriented interface
 * @export
 * @class TermsApi
 * @extends {BaseAPI}
 */
class TermsApi extends base_1.BaseAPI {
    /**
     * Returns the district for a term
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermsApi
     */
    getDistrictForTerm(id, options) {
        return exports.TermsApiFp(this.configuration).getDistrictForTerm(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the sections for a term
     * @param {string} id
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermsApi
     */
    getSectionsForTerm(id, limit, startingAfter, endingBefore, options) {
        return exports.TermsApiFp(this.configuration).getSectionsForTerm(id, limit, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a specific term
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermsApi
     */
    getTerm(id, options) {
        return exports.TermsApiFp(this.configuration).getTerm(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of terms
     * @param {number} [limit]
     * @param {string} [startingAfter]
     * @param {string} [endingBefore]
     * @param {'' | 'true' | 'false' | 'undefined'} [count]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermsApi
     */
    getTerms(limit, startingAfter, endingBefore, count, options) {
        return exports.TermsApiFp(this.configuration).getTerms(limit, startingAfter, endingBefore, count, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TermsApi = TermsApi;
//# sourceMappingURL=api.js.map